### Summary
Slice 4 delivers the V4 stack described in `/Users/darin/src/personal/DSRs/docs/specs/modules/breadboard.md:410-430` by implementing the typed ReAct module (two `Predict` leaves, tool builder, adapter-driven action/extract loop), removing the extra `display_progress` parameter from `dsrs::forward_all` so the ergonomic surface matches `forward_all(&module, inputs, concurrency)`, and adding module combinators that keep the existing `CallOutcome` metadata surface while remaining Facet-discoverable.

### Implementation Steps
1. Trim `forward_all` back to the 3-argument surface required by U48 so callers simply pass `(module, inputs, max_concurrency)` while still showing progress and preserving sorted, per-input `CallOutcome` metadata.
Files: `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs`
Existing signature(s): `pub async fn forward_all<M>(module: &M, inputs: Vec<M::Input>, max_concurrency: usize, display_progress: bool) -> Vec<CallOutcome<M::Output>>` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs:22-57`).
New signature(s): `[NEW] pub async fn forward_all<M>(module: &M, inputs: Vec<M::Input>, max_concurrency: usize) -> Vec<CallOutcome<M::Output>>` (still sorting by the original index and logging the same debug field counts but without the `display_progress` field in the `tracing::instrument`).
Required imports: keep the existing `use futures::stream::{self, StreamExt};`, `use kdam::{BarExt, tqdm};`, and `use tracing::debug;`; nothing new is required because the progress bar stays inside the same file.
Other changes: adjust every call site (`/Users/darin/src/personal/DSRs/crates/dspy-rs/examples/06-other-providers-batch.rs` and `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/evaluate/evaluator.rs`) to drop the `display_progress` argument so the binary call sites compile against the 3-argument helper, and ensure the `fields(...)` annotation inside `tracing::instrument` no longer references `display_progress`.

2. Introduce `ModuleExt` plus `Map`/`AndThen` wrappers so U51 consumers can derive new modules without reimplementing `Module::forward` while keeping the Facet walker focused on each wrapper's inner predictor state.
Files: create `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module_ext.rs` and re-export it from `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/mod.rs`.
Existing signature(s): the `Module` trait methods (`pub trait Module: Send + Sync { async fn forward(&self, input: Self::Input) -> CallOutcome<Self::Output>; }` at `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs:9-14`) plus the `CallOutcome` helpers `CallOutcome::ok`/`CallOutcome::err`/`CallOutcome::into_parts` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/call_outcome.rs:140-175`).
New signature(s): `[NEW] pub trait ModuleExt: Module + Sized { fn map<F, T>(self, map: F) -> Map<Self, F> where F: Fn(Self::Output) -> T + Send + Sync + 'static; fn and_then<F, T>(self, and_then: F) -> AndThen<Self, F> where F: Fn(Self::Output) -> Result<T, CallOutcomeErrorKind> + Send + Sync + 'static; }` plus `[NEW] pub struct Map<M, F> { inner: M, #[facet(skip)] map: F }` and `[NEW] pub struct AndThen<M, F>` with analogous layout, both deriving `Facet` so the walker still sees `inner` but not the closures.
Required imports: re-use `crate::{CallOutcome, CallOutcomeErrorKind}` when repackaging metadata, and import `facet::Facet` (if macros require) along with `std::marker::PhantomData` if needed for `Facet` boilerplate; no new external crates are required.
Other changes: implement `Module` for both wrappers so they await `self.inner.forward`, call `CallOutcome::into_parts()`, and repackage success via `CallOutcome::ok` while forwarding error kinds unchanged; `and_then` applies a fallible transform on success and always reuses the inner call metadata. Also ensure `core/mod.rs` re-exports the new trait and structs so downstream code can `use dspy_rs::ModuleExt`.

3. Add the typed ReAct module plus builder so Layer 1 exposes `ReAct::<S>` with two `Predict` leaves, a tool builder that accepts plain async functions, and an action/extract loop that yields `CallOutcome<S::Output>` per U14 and R11.
Files: create `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/react.rs` and update `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/mod.rs` to export the new module.
Existing signature(s): `Predict::call(...) -> CallOutcome<S::Output>` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:51-213`), `PredictBuilder` fluent API (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:223-271`), and `ChainOfThought::builder()` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/chain_of_thought.rs:120-165`) which serve as the template for the ReAct builder. Also rely on the `ReAct`-focused spec (e.g., `/Users/darin/src/personal/DSRs/docs/specs/modules/design_reference.md:919-940`) to guide the two-step loop and tool integration.
New signature(s): `[NEW] pub struct ReAct<S: Signature>` containing `action: Predict<ActionStep<S>>`, `extract: ChainOfThought<ExtractStep<S>>`, and the shared `Vec<Arc<dyn ToolDyn>>`; `[NEW] pub struct ReActBuilder<S: Signature>` mirrors `ChainOfThoughtBuilder` but adds `[NEW] pub fn tool<T>(self, name: impl Into<String>, desc: impl Into<String>, tool_fn: T) -> Self where T: ReActTool + Send + Sync + 'static` to wrap plain async handlers into `[NEW] struct ReActPlainTool`, so the builder can feed those handlers into both `PredictBuilder`s before `build()` collects them into the `ReAct` struct. Add `[NEW] pub fn with_extract_closure` or similar if needed to mutate tool-aware builder state.
Required imports: bring in `crate::core::{Module, Signature}`, `crate::modules::chain_of_thought::ChainOfThought`, `crate::predictors::{Predict, PredictBuilder}`, `crate::CallOutcome`, `rig::tool::ToolDyn`, `std::sync::Arc`, and the `facet` macros for the new struct. Also reuse `ChatAdapter` helper methods from `predict.rs` to format prompts/parse action/extract replies, and `CallOutcome` helpers to repackage metadata when the loop terminates.
Other changes: define `[NEW] ActionStep<S>` and `[NEW] ExtractStep<S>` signatures deriving `Signature` with `#[flatten]` fields so the LM sees the original input along with the per-iteration action/observation fields; implement the ReAct loop that calls the action predictor, dispatches to tool handlers (or treats the `final` signal as a terminal observation), feeds the generated observation plus the accumulated history into the extract predictor, and returns the final `S::Output` via `CallOutcome::ok` while carrying the metadata from the last LM interaction. Track metadata through every iteration so tool errors propagate correctly, and mark the ReAct struct with `#[derive(Facet)]` so the optimizer still discovers the `action` and `extract` predictors (see `/Users/darin/src/personal/DSRs/docs/specs/modules/shapes.md:60-90`).

4. Add new regression tests that exercise the three new surfaces (`forward_all`, `ModuleExt`, and ReAct builder/loop) to pin down the runtime behavior before writing implementation code.
Files: create `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_module_forward_all.rs`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_module_ext.rs`, and `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_react_builder.rs`.
Existing signature(s): `CallOutcome` helpers (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/call_outcome.rs:135-180`) and the `Module` trait (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs:9-14`) which the tests will target via small `impl Module` stubs.
New signature(s): `[NEW] async fn test_forward_all_order()` in `test_module_forward_all.rs`, `[NEW] async fn test_module_ext_map_and_and_then()` in `test_module_ext.rs`, and `[NEW] async fn test_react_executes_tool_loop()` in `test_react_builder.rs`, each annotated with `#[tokio::test]` (or `#[cfg_attr(miri, ignore = "...")]` as needed) so they can await `forward_all`/`ModuleExt` wrappers and, for the ReAct test, configure `TestCompletionModel` responses plus simple inlined tool handlers.
Required imports: reuse `crate::core::Module`, `crate::CallOutcome`, and `crate::forward_all` plus `tokio::test`/`tokio::spawn` helpers; the ReAct test will also import `crate::modules::ReAct`, `crate::configure`, `crate::TestCompletionModel`, and any builder helpers introduced above.
Other changes: the ReAct test should assert that the tool handler registered via `.tool(...)` runs and that `forward` returns the parsed `S::Output` produced by the extract `Predict`, while the other two tests assert ordering of `forward_all` results and that `map`/`and_then` correctly transform or propagate `CallOutcome` metadata.

### Test Plan
1. `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_module_forward_all.rs` — Assertion: `dsrs::forward_all` still buffers `max_concurrency` futures and reorders its outputs back to the caller’s input order while returning the per-input `CallOutcome`. Setup: simple bespoke `Module` that echoes its input along with `CallMetadata::default()` and a `Vec` of distinct integers; call the 3-arg helper with `max_concurrency` smaller than the input count. Expectation: results match the original order and the `CallOutcome` metadata is preserved even though the futures run out of order.
2. `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_module_ext.rs` — Assertion: `ModuleExt::map` applies the closure only on success and keeps metadata untouched, while `ModuleExt::and_then` applies a fallible transform that returns `Result<T, CallOutcomeErrorKind>` and preserves inner metadata. Setup: a stub module that returns `CallOutcome::ok`/`err` depending on input, wrapping it with `map`/`and_then` closures that mutate the output or return an error kind. Expectation: successful inputs are transformed, failures short-circuit with the original or closure-produced `CallOutcomeErrorKind`, and the metadata carried by `CallOutcome::into_parts()` is reused for mapped outcomes.
3. `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_react_builder.rs` — Assertion: the ReAct builder accepts a plain async `tool` handler and runs the action/extract loop to emit the typed `S::Output` inside a `CallOutcome`. Setup: configure `TestCompletionModel` (see `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/lm/client_registry.rs:1-83`) with canned action and extract responses formatted via `ChatAdapter::parse_sections`, register a tool via the builder that records its invocation arguments, and call `ReAct::forward` with a simple `Signature`. Expectation: the tool handler executes once with the provided arguments, the extract `Predict` parses the final fields into `S::Output`, and the returned `CallOutcome` includes the metadata from the last LM call.
