# Slice 2 Research: Augmentation + ChainOfThought

## 1. Slice 2 requirement checklist
- **U12 (Deref to augmented field)** — the demo must let callers treat `result.reasoning` as a first-class field, relying on `Deref` to reach the inner output; this is the core visibility change for F3 in V2 (`docs/specs/modules/breadboard.md:79-119`).
- **U13 (ChainOfThought library module)** — `ChainOfThought::<S>::new()` must exist, build on the augmentation combinator, and surface the same `CallOutcome`/metadata plumbing as `Predict` (`docs/specs/modules/breadboard.md:364-380`).
- **U16 (Strategy swap)** — swapping `Predict<QA>` for `ChainOfThought<QA>` must type-check without additional wiring, even though the output type shifts from `QAOutput` to `WithReasoning<QAOutput>` (`docs/specs/modules/breadboard.md:79-119`).
- **U17–U20 (Augmentation derive + wrapper)** — the proc-macro must support `#[derive(Augmentation)]`, the `#[augment(output, prepend)]` attribute, the generated wrapper (`WithReasoning<O>`), and the `Augmented<S, A>` type-level combinator so module authors never hand-write field plumbing (`docs/specs/modules/breadboard.md:364-380`).
- **U28, U29 (Predict<Augmented> field + `#[derive(Facet)]`)** — library modules like ChainOfThought must own an internally derived `Predict<Augmented<S, Reasoning>>` and stay discoverable via the Facet walker (`docs/specs/modules/breadboard.md:364-380`).
- **N14 (Augmentation macro)** — the compiler-side macro must generate the wrapper, `Deref`, `Facet`, and `BamlType` plumbing that keeps the flattened schema consistent (`docs/specs/modules/breadboard.md:364-380`).
- **F3 (Augmentation derive/combinator)** — the augmentation derive must emit `WithReasoning<O:` `BamlType + Facet>` plus `Deref`, flatten metadata, and the reusable `Augmented<S, A>` combinator (`docs/specs/modules/shapes.md:59-120`).
- **F11 (Library modules)** — ChainOfThought is the first concrete implementation; its definition demonstrates the output change, the `Module` implementation, and how it plugs into the walker and optimizer (`docs/specs/modules/shapes.md:67-140`).

## 2. Relevant types, schemas, and traits
### Signature surface (existing code)
- `MetaSignature` / `Signature` define the compile-time contract that `Predict` and all future modules satisfy. The trait currently exposes `instruction()`, cached `SignatureSchema`, field metadata, and the obsolete `from_parts`/`into_parts` helpers that Slice 2 will remove (`crates/dspy-rs/src/core/signature.rs:37-82`).
- `SignatureSchema`, `FieldSchema`, and `FieldPath` already capture flatten-aware metadata: each `FieldSchema` records the LM name, type, docs, and the `FieldPath` that records the flattened position inside nested `Facet` structs (`crates/dspy-rs/src/core/schema.rs:13-178`).

### Augmentation & ChainOfThought (design reference)
- `Augmentation` trait: `type Wrap<T: BamlType + Facet>: BamlType + Facet + Deref<Target = T>` (`docs/specs/modules/design_reference.md:247-308`).
- Derive output: `#[derive(Augmentation)]` on `Reasoning` must emit `WithReasoning<O>` (Facet, BamlType, flatten, `Deref`) plus the trait impl `impl Augmentation for Reasoning` (`docs/specs/modules/design_reference.md:259-308`).
- `Augmented<S, A>` is a zero-sized combinator that projects `S::Input` to `A::Wrap<S::Output>` and forwards instructions unchanged; `Predict` will hold `Augmented<S, Reasoning>` so the LM interacts with the extended schema (`docs/specs/modules/design_reference.md:299-309`).
- ChainOfThought module spec: `ChainOfThought<S>` wraps a `Predict<Augmented<S, Reasoning>>`, implements `Module`, and exposes `CallOutcome<WithReasoning<S::Output>>` (`docs/specs/modules/design_reference.md:861-885`).

### Predict / Demo / ChatAdapter patterns (current implementation)
- `Demo<S>` stores `input: S::Input` and `output: S::Output`. `Predict::call` builds prompts via `ChatAdapter`, streams LM responses, parses them back, and returns `CallOutcome<S::Output>` (`crates/dspy-rs/src/predictors/predict.rs:19-191`).
- `PredictBuilder` accumulates tools/demos/instruction overrides and feeds them into `Predict` (`crates/dspy-rs/src/predictors/predict.rs:200-271`).
- `ChatAdapter` typed helpers format prompts and parse responses against `SignatureSchema`, iterate over `FieldSchema::path()`, and insert responses back into nested `BamlValue` via `insert_baml_at_path` (`crates/dspy-rs/src/adapter/chat.rs:430-757`, `883-930`).
- Macro scaffolding: `#[derive(Signature)]` already parses `#[input]`, `#[output]`, `#[flatten]`, alias, format, and constraint attributes before emitting the generated types (`crates/dsrs-macros/src/lib.rs:66-160`).

## 3. Existing code patterns to extend
- **Typed pipeline**: `Predict::call` (lines 51-190) shows the full trace: build system prompt, emit demo/inputs with `ChatAdapter`, call the LM, parse typed response, and convert to `CallOutcome`. ChainOfThought will reuse the adapter + `CallOutcome` plumbing (`crates/dspy-rs/src/predictors/predict.rs:51-191`).
- **Relational schema + flatten traversal**: `SignatureSchema::build` walks `Facet` fields, handles `flatten` by recursively extending each `FieldPath`, and creates the `FieldSchema` records that `ChatAdapter` already consumes (`crates/dspy-rs/src/core/schema.rs:105-200`).
- **Path-aware insertion**: `ChatAdapter::format_user_message_typed`, `.format_assistant_message_typed`, and `.parse_response_typed` all rely on `FieldPath` to read/write nested data, demonstrating the intended `F7` path navigation (`crates/dspy-rs/src/adapter/chat.rs:525-757`, `883-930`).
- **Demo formatting**: `format_demo_typed` currently splits a `Signature` via `into_parts`; Slice 2 will switched to working with `Demo<S>` directly once `Signature` no longer requires `into_parts` (`crates/dspy-rs/src/adapter/chat.rs:572-581`).
- **Macro parsing stage**: `parse_signature_fields` and the `ParsedField` structure show where `#[flatten]` and future `#[augment]` attributes will hook into code generation (`crates/dsrs-macros/src/lib.rs:66-160`).

## 4. Gaps between current implementation and V2 requirements
- **Trait surface mismatch**: `Signature` still requires `from_parts`/`into_parts` and exposes shapish helper lists; spec (S7) calls for dropping those methods and simplifying to input/output types + instructions so `Augmented<S, A>` can be a pure combinator (`docs/specs/modules/spikes/S7-augmentation-derive-feasibility.md:1-78`).
- **Augmentation derive not implemented**: no `#[derive(Augmentation)]` macro exists yet, so there is no `WithReasoning<O>` wrapper or `Augmented<S, A>` combinator in code; the stack currently still uses `FieldSpec` metadata and direct `Signature` splitting (`crates/dspy-rs/src/core/signature.rs` and `crates/dspy-rs/src/adapter/chat.rs:572-757`).
- **ChainOfThought module missing**: no `ChainOfThought<S>` type, `Predict<Augmented<S, Reasoning>>`, or module registration exists in the workspace, so `U13` and `U28` cannot be satisfied (`docs/specs/modules/design_reference.md:861-884`).
- **Residual split helpers still present**: Slice 1 moved `Predict` storage to `Vec<Demo<S>>` and typed parse/format to `FieldPath`, but deprecated conversion paths still rely on `Signature::from_parts`/`into_parts` (`PredictBuilder::demo_signature`, `ChatAdapter::format_demo_typed`) and should be removed as part of S7 cleanup (`crates/dspy-rs/src/predictors/predict.rs:230-347`, `crates/dspy-rs/src/adapter/chat.rs:568-581`).
- **Legacy compatibility surface still depends on `FieldSpec`/`MetaSignature`**: while typed path is schema-first, V2 implementation must avoid regressing compatibility during augmentation rollout (especially where legacy adapters/optimizers still consume JSON field maps) (`crates/dspy-rs/src/core/signature.rs:10-67`, `crates/dspy-rs/src/predictors/predict.rs:273-399`).

## 5. Spec ambiguities + recommended decisions
- **Mutability / pattern limitations (S3)**: nested `Deref` already handles reads/methods; pattern matching and mutation require explicit destructuring or `DerefMut`. Recommendation: keep `Deref` only for now, document that pattern matching must unwrap layer-by-layer, and add compile tests for both supported (field reads/methods) and unsupported (pattern match/mutation without `DerefMut`) scenarios (`docs/specs/modules/spikes/S3-augmentation-deref-composition.md:24-104`).
- **Path-aware reconstruction**: the design reference spells out two options (Facet `Partial` vs building nested `BamlValue`), and no final decision is written down (`docs/specs/modules/design_reference.md:323-327`). Recommendation: start with the simpler `BamlValue` reconstruction that follows `FieldPath`, then refactor to `Partial` only if streaming/evaluation requires it, because `ChatAdapter::parse_response_typed` already expects to build a `BamlValue` map (`crates/dspy-rs/src/adapter/chat.rs:609-757`).
- **Augmentation derive + trait shape (S7)**: `#[derive(Augmentation)]` must generate generic wrappers and rely on the existing Facet/BamlType derives; there is no need for `from_parts`/`into_parts` in the trait anymore (`docs/specs/modules/spikes/S7-augmentation-derive-feasibility.md:1-78`). Recommendation: adopt the simplified `Signature` trait from S7 and codegen that emits `Augmented<S, A>` plus wrapper types with flatten metadata.

## 6. Recommended implementation approach
1. **Simplify `Signature` & flow**: drop `from_parts`/`into_parts`, restrict `Signature` to `Input`, `Output`, and `instruction()`, and change `Predict`, demos, and `ChatAdapter::format_demo_typed` to work with `Demo<S>` directly as S7 prescribes (`docs/specs/modules/spikes/S7-augmentation-derive-feasibility.md:42-78`).
2. **Augmentation derive + combinator**: implement `#[derive(Augmentation)]` to emit `WithReasoning<O>` (`Facet`, `BamlType`, `flatten`, `Deref`) and register the generated wrapper in the `Augmentation` trait, plus the `Augmented<S, A>` phantom type that maps `S::Output` → `A::Wrap<S::Output>` (`docs/specs/modules/design_reference.md:247-353`).
3. **ChainOfThought module**: add `ChainOfThought<S>` (Facet struct with a `Predict<Augmented<S, Reasoning>>`, `Module` implementation forwarding to `predict.call`) and ensure the library registers any factory needed for the optimizer + walker (`docs/specs/modules/design_reference.md:861-885`).
4. **Macro + metadata wiring**: extend `dsrs-macros` to emit `FieldSchema` metadata that records `FieldPath`s for both user fields and flattened wrapper fields; ensure the `#[augment]` attribute marks `inner` appropriately so `collect_fields` can rebuild nested paths (`crates/dsrs-macros/src/lib.rs:66-160`, `crates/dspy-rs/src/core/schema.rs:180-258`).
5. **Adapter plumbing**: preserve the existing `FieldPath`-based typed path and add augmentation-specific roundtrip tests verifying composed wrappers survive `insert_baml_at_path`/typed extraction (`crates/dspy-rs/src/adapter/chat.rs:525-757`, `883-930`).
6. **Tests/verification**:
   - Unit tests for `WithReasoning<WithConfidence<QAOutput>>` to confirm `result.reasoning`, `result.answer`, and `result.confidence` resolve via `Deref`, while pattern matching/mutation fail unless `DerefMut` is explicitly derived (S3 acceptance, `docs/specs/modules/spikes/S3-augmentation-deref-composition.md:69-104`).
   - Integration test that instantiates `ChainOfThought<QA>`, feeds a stubbed LM, and asserts the LM prompt/output includes both reasoning and answer fields at the flattened level.
   - Round-trip test that builds a `Demo<Augmented<QA, Reasoning>>`, formats it, parses the LM response, and verifies `ChatAdapter` produces a `WithReasoning<QAOutput>` that reconstructs the expected nested `BamlValue` (`crates/dspy-rs/src/adapter/chat.rs:568-748`).
7. **Documentation + decision notes**: update the research doc (this file) and the design reference to mention the mutability constraints, pattern-matching guidance, and the `BamlValue` path reconstruction choice so downstream authors follow the same rules (`docs/specs/modules/design_reference.md:333-356`).
