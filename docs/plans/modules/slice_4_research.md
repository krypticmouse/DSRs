### Spec Requirements
- `U14` / R11 (shapes + breadboard): Deliver the ReAct library module with a builder that wires plain `async` tool handlers (`.tool("name","desc", fn)`) through two `Predict` leaves (action + extraction), reuses the shared adapter pipeline, and returns `CallOutcome<S::Output>` so the tool loop and augmentation stack live entirely in Layer 1/F11.
- `U48` (breadboard): Provide `dsrs::forward_all(&module, inputs, concurrency)` as an ergonomic batch helper that launches up to `max_concurrency` in-flight forwards, reports progress, and returns `Vec<CallOutcome<Output>>` so the P1 caller can inspect per-input metadata without forcing new trait methods.
- `U51` (breadboard): Expose module combinators (e.g., `Module::map` plus a fallible `and_then`) so P1 users can wrap an existing `Module` with a closure instead of writing `impl Module`; the combinators must remain Facet-transparent (the walker sees the inner module) and preserve `CallOutcome` metadata.

### Existing Code Inventory
- `pub trait Module: Send + Sync { type Input: Send + Sync + 'static; type Output: Send + Sync + 'static; async fn forward(&self, input: Self::Input) -> CallOutcome<Self::Output>; }` — `crates/dspy-rs/src/core/module.rs:8-14`
- `#[tracing::instrument(...)] pub async fn forward_all<M>(module: &M, inputs: Vec<M::Input>, max_concurrency: usize, display_progress: bool) -> Vec<CallOutcome<M::Output>> where M: Module + ?Sized` — `crates/dspy-rs/src/core/module.rs:16-58`
- `pub struct CallOutcome<O> { metadata: CallMetadata, result: Result<O, CallOutcomeErrorKind> }` plus `CallOutcome::ok`, `CallOutcome::err`, `CallOutcome::into_result`, and the `Deref` impl so every module returns a single `CallOutcome` surface with metadata; see `crates/dspy-rs/src/core/call_outcome.rs:24-225`.
- `pub struct Demo<S: Signature> { pub input: S::Input, pub output: S::Output }` and `pub struct Predict<S: Signature> { tools: Vec<Arc<dyn ToolDyn>>, demos: Vec<Demo<S>>, instruction_override: Option<String>, _marker: PhantomData<S> }` with `Predict::call(&self, input) -> CallOutcome<S::Output>` (instrumented via `#[tracing::instrument]`, `ChatAdapter`, LM invocation, and metadata gathering) and `Predict::builder()` — `crates/dspy-rs/src/predictors/predict.rs:19-213`.
- `pub struct PredictBuilder<S: Signature>` with fluent helpers `demo`, `with_demos`, `add_tool`, `with_tools`, `instruction`, and `build` — `crates/dspy-rs/src/predictors/predict.rs:222-271`.
- `#[derive(Augmentation, Clone, Debug)] pub struct Reasoning { #[output] pub reasoning: String }` plus `pub type ChainOfThoughtOutput<S> = WithReasoning<<S as Signature>::Output>` — `crates/dspy-rs/src/modules/chain_of_thought.rs:9-17`.
- `pub struct ChainOfThought<S: Signature> { predictor: Predict<Augmented<S, Reasoning>> }` with `ChainOfThought::new`, `call`, `Module` impl returning `CallOutcome<WithReasoning<S::Output>>`, and `MetaSignature`/`Optimizable` impls that delegate to the inner `Predict` — `crates/dspy-rs/src/modules/chain_of_thought.rs:18-118`.
- `pub struct ChainOfThoughtBuilder<S: Signature>` that proxies to `PredictBuilder<Augmented<S, Reasoning>>` via `demo`, `with_demos`, `add_tool`, `with_tools`, `instruction`, and `build` — `crates/dspy-rs/src/modules/chain_of_thought.rs:120-165`.

### Gap Analysis
- `U14` (ReAct builder + tools): [NEW] No `ReAct` module exists yet. The only library module is `ChainOfThought`, so we need to add `ReAct<S>` (two `Predict` leaves plus optional tool set), a builder that accepts plain async functions per R11 instead of just `ToolDyn`, wiring adapter building blocks for the action/extract loop, and exposing `CallOutcome` metadata in the same way `Predict` does.
- `U48` (`dsrs::forward_all`): [MODIFY] `crates/dspy-rs/src/core/module.rs:22` already provides batching semantics and returns `Vec<CallOutcome<Output>>`, but the current API requires a fourth `display_progress: bool` argument. The slice spec surface is `forward_all(&module, inputs, concurrency)`; add/adjust API to meet that ergonomic contract while preserving current behavior.
- `U51` (`module.map/.and_then`): [NEW] There are no combinators yet. We must add `Map<M, F>`/`AndThen<M, F>` (or similar) wrappers, derive Facet while exposing the `inner: M` field, and implement `Module` so closures transform the inner result while preserving `CallOutcome` metadata. The spec mandates that the walker continue to see the inner module (manual Facet impl or `#[facet(flatten)]` on `inner`) even though closures are opaque.

### Patterns & Conventions
- Fluent builders wrap `PredictBuilder` instances (`ChainOfThoughtBuilder::demo/with_tools/instruction` via `PredictBuilder`) and route final `build` through `Predict::builder()` — follow this pattern when crafting the `ReAct` builder so that demos, tools, and instructions reuse the same `Predict` plumbing (`crates/dspy-rs/src/modules/chain_of_thought.rs:120-165`).
- LM leaf modules keep a single return surface: `Predict::call` formats system/user messages via `ChatAdapter`, calls the LM, parses via `ChatAdapter::parse_response_typed`, and ultimately returns `CallOutcome<S::Output>` with rich `CallMetadata` (`crates/dspy-rs/src/predictors/predict.rs:63-213`). Any new module (including ReAct and combinators) should reuse `CallOutcome` rather than adding new result wrappers.
- Operational helpers use async streams + progress instrumentation: `forward_all` uses `futures::stream::buffer_unordered`, `tqdm!`, and `tracing::instrument` while sorting results to preserve input order (`crates/dspy-rs/src/core/module.rs:16-58`). New concurrency utilities or wrappers should follow the same observable behavior.

### Spec Ambiguities
- The ReAct tool builder is described as accepting “plain Rust async functions” (`docs/specs/modules/shapes.md:R11`, `docs/specs/modules/breadboard.md:414`), but the current tool stack is built around `rig::tool::ToolDyn`. It’s unclear whether the builder should wrap `Fn(...) -> impl Future<Output = String>` (or `ToolOutcome`) into `ToolDyn`, or expose a dedicated `ToolSpec` that holds the name/description/function pair.
- `U51` mentions both `.map(|output| ...)` and an `.and_then(...)` for fallible transforms, yet the spec doesn’t say whether the closures operate on raw `Output`, on `CallOutcome`, or how `CallMetadata` should be forwarded. Do errors bubble up via `CallOutcomeError`, via `Result`, or should `and_then` accept `FnOnce(Output) -> CallOutcome<T>` directly?
- The requirement that module combinators be “Facet-transparent” (breadboard boundary note) leaves open how to implement map/and_then structs: the closure field can’t derive `Facet`, so we need guidance on how to annotate the struct (e.g., `#[facet(skip)]` on the closure, manual Facet impl that only walks `inner`) and whether additional metadata (path prefix adjustments) is needed to keep the walker deterministic.

### Recommended Approach
1. Build `ReAct<S>` as a Facet-derived struct that owns two `Predict` leaves (`action`, `extract`) plus the tool registry, exposes a builder modeled on `ChainOfThoughtBuilder`, and implements `Module` by running the action/extract loop outlined in `docs/specs/modules/design_reference.md#12-library-modules`. The builder should accept demos/tools/instruction like the existing builders but also `.tool("name","desc", tool_fn)` that converts tool functions into `ToolDyn` (or a new thin wrapper) so the LM call can pass them to `lm.call`. Track metadata through the same `CallOutcome` path as `Predict::call`.
2. Reuse `dsrs::forward_all` for batching; no new helper is needed unless we discover new requirements during ReAct development. Keep the current progress instrumentation and sorted reassembly of results so batch behavior stays predictable for slice consumers.
3. Introduce module extensions such as `ModuleExt::map` / `and_then` that wrap an inner module and a closure. The wrapper struct should derive Facet (explicitly exposing `inner`; mark the closure `#[facet(skip)]` or hand-write `Facet` if necessary) so the optimizer still sees the `Predict` leaves. Implement `Module` for the wrapper by awaiting `inner.forward`, then applying the closure to the successful output (propagating `CallOutcome` errors unchanged) and returning a new `CallOutcome`. `and_then` can accept closures returning `CallOutcome<T>` to let closures emit rich metadata when they themselves perform LM calls or validations.
4. As part of the implementation, revisit the `Module`/`CallOutcome` surface to ensure the new combinators and ReAct module reuse the existing builder/instrumentation patterns rather than duplicating state. Use the `CallOutcome` metadata API to funnel tool traces and parsing diagnostics all the way through the new wrappers.
