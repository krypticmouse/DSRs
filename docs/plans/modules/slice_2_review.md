# Slice 2 Adversarial Review

## Spec Fidelity

### ChainOfThought must be a `Facet` value for F6 discovery
- **Ground truth:** `shapes.md` defines F6 as “Facet-powered parameter discovery” and F11 says every library module (including `ChainOfThought`) must be discoverable through that walker so downstream components (ProgramGraph, optimizers) can iterate `Predict` leaves. `design_reference.md` even shows `ChainOfThought` annotated with `#[derive(Facet)]` and passed to `ProgramGraph::from_module<M: Facet>` so `named_parameters` can find `predict` and add it as a node. *(docs/specs/modules/shapes.md:61‑67, docs/specs/modules/design_reference.md:840‑885)*
- **Implementation:** `crates/dspy-rs/src/modules/chain_of_thought.rs` defines `ChainOfThought` with only `#[derive(Default)]` and `#[derive(Augmentation, Clone, Debug)]` on `Reasoning`; there is no `#[derive(Facet)]` on the module itself nor a manual `Facet` impl for the struct, so the `predictor` field is invisible to reflection and the walker described in F6 cannot reach the `Predict`. *(chain_of_thought.rs:16‑53)*
- **Impact:** Without `Facet`, `ChainOfThought` never contributes its internal `Predict` to the optimizer/runtime graph, so the promise of automatic discovery in R4/F6/F11 stays unfulfilled. Strategy swap a la U16 cannot be validated by the future `ProgramGraph` projection. Please derive/implement `Facet` for the module and expose the `predictor` field so the shape walker can enumerate the leaf predictor.

### Module interface still returns untyped `Prediction`
- **Ground truth:** The ChainOfThought example in `design_reference.md` ties the typed module surface directly to the typed output: `Module::forward` takes `S::Input` and returns `CallOutcome<WithReasoning<S::Output>>`, mirroring the `Predict` call. This is the API that makes the “type swap” story work—upgrading `Predict<QA>` to `ChainOfThought<QA>` should only change the output type while reusing the same module call. *(docs/specs/modules/design_reference.md:861‑885)*
- **Implementation:** The current `Module` trait (and `ChainOfThought`’s impl) still operates on raw `Example`/`Prediction`. `ChainOfThought::forward` simply calls `self.predictor.forward` and returns `CallOutcome<Prediction>`, despite `call` returning `CallOutcome<WithReasoning<S::Output>>`. There is no typed wrapper around the module entry point, so clients calling through `Module` do not observe the augmented fields directly. *(chain_of_thought.rs:45‑60)*
- **Impact:** The breadboard story for U13/U16 (swap `Predict` for `ChainOfThought`, get `.reasoning` via the same call) cannot be validated through the module trait because the interface still reserializes everything into `Prediction`. Please align `Module::forward` with the design (or introduce a typed module trait) so the `ChainOfThought` module can expose typed outcomes without rebuilding the `Prediction` map.

## Shape & Optimization Compliance

### Legacy optimizer path cannot see the inner predictor
- **Ground truth:** F6 expects every `Module` to reveal its `Predict` leaves via reflection rather than custom `Optimizable` plumbing, and the design reference projects any `Facet` module into `ProgramGraph::from_module` by calling `named_parameters`. Until the walker lands, the old `Optimizable` interface still has to work, meaning library modules must forward their `Predict` handles through `parameters()`. *(docs/specs/modules/shapes.md:61‑67, docs/specs/modules/design_reference.md:840‑885)*
- **Implementation:** `ChainOfThought::parameters` returns `IndexMap::new()` even though the struct contains `predictor: Predict<...>`. There is no surrogate for the walker yet, so no optimizer can mutate the demos/instruction of the wrapped predictor through the existing entry points. *(chain_of_thought.rs:98‑114)*
- **Impact:** Optimizers (COPRO/MIPRO/GEPA) that still rely on `Optimizable::parameters` cannot discover or tune the inner `Predict`, defeating part of R4 and breaking the planned optimizer hand-off until the Facet walker is wired in. Please expose the predictor in `parameters()` or wire the new walker so `ChainOfThought` participates in parameter traversal from the start.
