### Spec Requirements
1. **F6 / U30–U31 / N18 (docs/specs/modules/breadboard.md:91-147):** Provide `named_parameters(&mut module)` that walks the Facet shapes for every `#[facet(dsrs::parameter)]` leaf, emits deterministic dotted paths, and returns `Vec<(String, &mut dyn DynPredictor)>` so optimizers can mutate predictors inside typed modules.
2. **F8 / U32–U37 / N21–N23 (docs/specs/modules/breadboard.md:112-147; docs/specs/modules/design_reference.md:717-768):** Define the `DynPredictor` trait that exposes schema/demos/instruction/state operations plus `forward_untyped(BamlValue)`, and wire `Predict<S>` (and future library modules) through conversions `Demo<S> ↔ Example` and `BamlValue ↔ S::Input` so the optimizer works with untyped examples while keeping the typed state consistent.
3. **U50 (docs/specs/modules/breadboard.md:56-91, docs/specs/modules/dspy_module_system_reference/06_optimizers.md:86-181):** Surface `optimizer.compile(&mut module, trainset, metric)` as the P1→P3 entry point that takes a `Vec<Example>` trainset (and an `Evaluator`/metric callback), locks `&mut Module`, and drives discovery + optimizer mutation via the new walker + `DynPredictor` handles.

### Existing Code Inventory
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs:9-18`: `pub trait Module: Send + Sync { type Input: BamlType + for<'a> Facet<'a> + Send + Sync; type Output: BamlType + for<'a> Facet<'a> + Send + Sync; async fn forward(&self, input: Self::Input) -> Result<Predicted<Self::Output>, PredictError>; async fn call(&self, input: Self::Input) -> Result<Predicted<Self::Output>, PredictError> { self.forward(input).await } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/module.rs:81-91`: `pub trait Optimizable { fn get_signature(&self) -> &dyn MetaSignature { todo!() } fn parameters(&mut self) -> IndexMap<String, &mut dyn Optimizable>; fn update_signature_instruction(&mut self, instruction: String) -> anyhow::Result<()> { todo!() } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/signature.rs:23-32`: `pub trait MetaSignature: Send + Sync { fn demos(&self) -> Vec<Example>; fn set_demos(&mut self, demos: Vec<Example>) -> Result<()>; fn instruction(&self) -> String; fn input_fields(&self) -> Value; fn output_fields(&self) -> Value; fn update_instruction(&mut self, instruction: String) -> Result<()>; fn append(&mut self, name: &str, value: Value) -> Result<()>; }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/signature.rs:34-58`: `pub trait Signature: Send + Sync + 'static { type Input: BamlType + for<'a> Facet<'a> + Send + Sync; type Output: BamlType + for<'a> Facet<'a> + Send + Sync; fn instruction() -> &'static str; fn schema() -> &'static SignatureSchema where Self: Sized { SignatureSchema::of::<Self>() } fn input_shape() -> &'static Shape; fn output_shape() -> &'static Shape; fn input_field_metadata() -> &'static [FieldMetadataSpec]; fn output_field_metadata() -> &'static [FieldMetadataSpec]; fn output_format_content() -> &'static OutputFormatContent where Self: Sized { Self::schema().output_format() } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/schema.rs:73-179`: `pub struct SignatureSchema { instruction: &'static str, input_fields: Box<[FieldSchema]>, output_fields: Box<[FieldSchema]>, output_format: Arc<OutputFormatContent>, }` and `impl SignatureSchema { pub fn of<S: Signature>() -> &'static Self { ... build::<S>() ... } fn build<S: Signature>() -> Result<Self, String> { ... collect_fields(...) ... } pub fn input_fields(&self) -> &[FieldSchema]; pub fn output_fields(&self) -> &[FieldSchema]; ... }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:18-40`: `#[derive(facet::Facet)] pub struct Demo<S: Signature> { pub input: S::Input, pub output: S::Output }` and `#[derive(facet::Facet)] pub struct Predict<S: Signature> { #[facet(skip, opaque)] tools: Vec<Arc<dyn ToolDyn>>, #[facet(skip, opaque)] demos: Vec<Demo<S>>, instruction_override: Option<String>, #[facet(skip, opaque)] _marker: PhantomData<S>, }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:43-200`: `impl<S: Signature> Predict<S> { pub fn new() -> Self { ... } pub fn builder() -> PredictBuilder<S> { ... } #[tracing::instrument(...)] pub async fn call(&self, input: S::Input) -> Result<Predicted<S::Output>, PredictError> where S::Input: BamlType, S::Output: BamlType { ... } pub async fn forward(&self, input: S::Input) -> Result<Predicted<S::Output>, PredictError> { self.call(input).await } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:321-413`: conversion helpers `fn demo_from_example<S: Signature>(example: Example) -> Result<Demo<S>>`, `fn example_from_demo<S: Signature>(demo: &Demo<S>) -> Result<Example>`, and `fn prediction_from_output<S: Signature>(output: &S::Output, lm_usage: LmUsage, node_id: Option<usize>) -> Result<Prediction>` that already convert between typed demos/output and the legacy `Example`/`Prediction` structs.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:415-468`: `impl<S> Module for Predict<S> where S: Signature + Clone, S::Input: BamlType, S::Output: BamlType { type Input = S::Input; type Output = S::Output; async fn forward(&self, input: S::Input) -> Result<Predicted<S::Output>, PredictError> { Predict::call(self, input).await } }` and `impl<S> Predict<S> { pub async fn forward_untyped(&self, input: BamlValue) -> Result<Predicted<BamlValue>, PredictError> { ... } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:471-535`: `impl<S> MetaSignature for Predict<S> { fn demos(&self) -> Vec<Example> { ... } fn set_demos(&mut self, demos: Vec<Example>) -> Result<()> { ... } fn instruction(&self) -> String { ... } fn input_fields(&self) -> Value { ... } fn output_fields(&self) -> Value { ... } fn update_instruction(&mut self, instruction: String) -> Result<()> { ... } fn append(&mut self, _name: &str, _value: Value) -> Result<()> { ... } }` and `impl<S> Optimizable for Predict<S> { fn get_signature(&self) -> &dyn MetaSignature { self } fn parameters(&mut self) -> IndexMap<String, &mut dyn Optimizable> { IndexMap::new() } fn update_signature_instruction(&mut self, instruction: String) -> anyhow::Result<()> { ... } }`.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/chain_of_thought.rs:114-135`: `impl<S> Optimizable for ChainOfThought<S> { fn get_signature(&self) -> &dyn MetaSignature { self } fn parameters(&mut self) -> IndexMap<String, &mut dyn Optimizable> { let mut parameters = IndexMap::new(); parameters.insert("predictor".to_string(), &mut self.predictor as &mut dyn Optimizable); parameters } fn update_signature_instruction(&mut self, instruction: String) -> anyhow::Result<()> { self.predictor.update_signature_instruction(instruction) } }`, illustrating the current manual traversal that the new walker should replace.
- `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mod.rs:19-24`: `pub trait Optimizer { async fn compile<M>(&self, module: &mut M, trainset: Vec<Example>) -> Result<()> where M: Module<Input = Example, Output = Prediction> + Optimizable + Evaluator; }` demonstrates the existing optimizer contract built on `Optimizable`/legacy metadata.

### Gap Analysis
1. **F6 / U30–U31 / N18 (`named_parameters` walker)**
   - [NEW] No `named_parameters` entry exists; current discovery relies on the old `Optimizable` trait and per-module overrides such as `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/chain_of_thought.rs:114-135`. Implementing the Facet walker requires new visitor logic that inspects `Shape` metadata, detects `#[facet(dsrs::parameter)]`, formats deterministic dotted paths, and returns `Vec<(path, &mut dyn DynPredictor)>`. Container traversal remains deferred per S5 (errors when a Vec/Option/HashMap wraps a parameter).
2. **F8 / U32–U37 / N21–N23 (`DynPredictor` operations and conversions)**
   - [NEW] The trait described in the spec does not exist yet. Implement `DynPredictor` (schema, instruction, demos, state, `forward_untyped`). `Predict` already stores demos/instruction and exposes conversions via `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:321-413`, so reuse those helpers, expand them for `dump_state`/`load_state`, and wire `Predict::forward_untyped` (`:415-468`) into the trait. `Predict` also already implements `MetaSignature`/`Optimizable` (`:471-535`), but those should be retained only for now while `DynPredictor` becomes the primary optimizer surface.
3. **U50 (`optimizer.compile` entry point)**
   - [MODIFY] The current optimizer contract (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mod.rs:19-24`) requires `Optimizable`/`Prediction`. Update it to accept `Module` returning `Predicted` results, replace `Optimizable` bounds with the new `named_parameters` + `DynPredictor` handles, and ensure `trainset: Vec<Example>` plus the existing `Evaluator` (metric) are still passed through. Optimizer implementations (Copro, MIPRO, GEPA) must be refactored to call `named_parameters` and mutate `DynPredictor` handles rather than `MetaSignature`, while the `optimizer.compile(&mut module, ...)` surface drives that flow (U50).

### Patterns & Conventions
- Facet metadata is tuned using `facet` attributes; `Predict` hides non-parameter fields with `#[facet(skip, opaque)]` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:31-41`), so new discovery code should rely on those flags and emit handles only from `#[facet(dsrs::parameter)]` leaves.
- Async entry points carry `tracing::instrument` annotations (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:57-205` and `:415-468`) with structured fields; follow this style when adding `named_parameters`/`DynPredictor` helpers so optimizer logging automatically surfaces names and counts.
- Schema values are cached via `OnceLock<Mutex<HashMap<TypeId, &'static SignatureSchema>>>` and leaked with `Box::leak` to obtain `'static` slices (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/schema.rs:81-134`); new code that derives `SignatureSchema` for optimizer use should reuse the same caching pattern to avoid duplicate builds.

### Spec Ambiguities
1. **Container traversal for optimizer discovery (S5):** The spec says the walker should error on containers whose inner type carries `dsrs::parameter` (`docs/specs/modules/breadboard.md:144-146`), but the S5 spike proposes a hybrid solution when needed. For V5, assume only struct-field recursion is required and make `named_parameters` emit a clear diagnostic before descending into Vec/Option/HashMap; add a TODO referencing S5 to revisit once a real container-based module appears.
2. **`optimizer.compile` parameters (`trainset`, `metric`):** Breadboard U50 mentions `trainset`/`metric`, while the existing Rust `Optimizer` trait takes `trainset: Vec<Example>` and bounds `M: Evaluator` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mod.rs:19-24`). Clarify that the metric is supplied via the existing `Evaluator` trait and the signature stays `compile(&mut module, trainset: Vec<Example>)`, with the new entry point layering on the same metric hook so downstream code does not duplicate the Python examples (docs/specs/modules/dspy_module_system_reference/06_optimizers.md:86-181).
3. **DynPredictor handle extraction (S2):** The mechanism depends on `Predict` exposing a `PredictAccessorFns` payload (`docs/specs/modules/design_reference.md:605-774`), but the spec does not spell out how to register that attribute today. Resolve by adding a `#[facet(attr = ...)]` payload in `Predict` so the walker can downcast to the accessor functions exactly like `WithAdapterFns`, and document the unsafe boundary for auditors.

### Recommended Approach
1. **Define the optimizer bridge types:** Add a `DynPredictor` trait (schema, demos, instruction, state, `forward_untyped`) and a `PredictState` record for dump/load. Make `Predict<S>` carry a `PredictAccessorFns` facet attribute (fn-pointer payload) and implement `DynPredictor` by reusing the conversion helpers already in `predict.rs` plus the new state getters/setters.
2. **Build the Facet walker:** Implement `named_parameters` (and helper `walk_value`) that inspects `value.shape()`, matches `Def::Struct`, recurses through fields, formats paths according to the deterministic grammar, and uses the facet accessor payload to obtain `&mut dyn DynPredictor`. Emit an error when encountering container definitions with `dsrs::parameter` until S5 is resolved.
3. **Wire optimizers to the new surface:** Update `Optimizer` trait implementations (Copro/MIPRO/GEPA) to call `named_parameters`, mutate `DynPredictor` handles (schema/demos/instruction/state), and use `forward_untyped` when they need untyped execution, instead of relying on `Optimizable`/`MetaSignature`. Keep legacy implementations around as shims until the new flow is stable.
4. **Expose `optimizer.compile` entry:** Provide the P1-facing `optimizer.compile(&mut module, trainset, metric)` hook that locks the module, fetches predictors via the walker, runs the chosen optimizer strategy, and returns after the mutator has finished. Tie the existing `Evaluator`/`Example` trainset types into this surface so the Python-inspired semantics are preserved.
5. **Validate with tests and docs:** Add unit tests that run `named_parameters` on a struct like `ChainOfThought`, verify the path list and handle mutability, and assert error behavior for container-wrapped predictors. Update docs/specs references (breadboard and design reference) to mention the new entry point and the fact that `DynPredictor` is the optimizer contract. Keep any remaining `MetaSignature`/`Optimizable` uses as compatibility snapshots until the cleanup pass after V5 + V6.
