### Summary
Slice 5 delivers the optimizer-facing half of the breadboard: the F8 `DynPredictor` trait plus the F6 `named_parameters` walker so optimizers can mutate typed `Predict<S>` leaves without `Optimizable` plumbing, and it exposes the P1→P3 entry point `optimizer.compile(&mut module, trainset, metric)` that retains the `Evaluator`-backed metric hook (U50) while wiring through the new walker/trait plumbing described in `docs/specs/modules/breadboard.md:91-147` and `docs/specs/modules/dspy_module_system_reference/06_optimizers.md:82-181`.

### Implementation Steps
1. Introduce the dyn-predictor core helpers.
   - Files: `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/dyn_predictor.rs` [NEW], update `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/mod.rs:1-19` to expose it.
   - Existing signature(s): `core/mod.rs` currently only re-exports `errors`, `predicted`, `lm`, `module`, `module_ext`, `schema`, `settings`, `signature`, `specials` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/mod.rs:1-19`).
   - New signature(s): `[NEW] pub trait DynPredictor: Send + Sync { fn schema(&self) -> &SignatureSchema; fn instruction(&self) -> String; fn set_instruction(&mut self, instruction: String); fn demos_as_examples(&self) -> Vec<Example>; fn set_demos_from_examples(&mut self, demos: Vec<Example>) -> Result<()>; fn dump_state(&self) -> PredictState; fn load_state(&mut self, state: PredictState) -> Result<()>; async fn forward_untyped(&self, input: BamlValue) -> Result<Predicted<BamlValue>, PredictError>; }` plus `[NEW] pub struct PredictState { demos: Vec<Example>, instruction_override: Option<String> }`, `[NEW] pub struct PredictAccessorFns { accessor: fn(*mut ()) -> *mut dyn DynPredictor }`, and `[NEW] pub enum NamedParametersError { Container { path: String, ty: &'static str }, MissingAttr { path: String } }` to surface the container-error requirement from `docs/specs/modules/breadboard.md:40-54`.
   - Required imports: `use crate::{BamlValue, core::schema::SignatureSchema, data::example::Example, PredictError, Predicted}; use facet::{Attr, Def, Field}; use facet::define_attr_grammar;` so the new module can both describe the `dsrs::parameter` attribute (`define_attr_grammar!` from `docs/specs/modules/design_reference.md:128-134`) and house the visitor helpers.
   - Other changes: capture the `#[facet(dsrs::parameter = ...)]` payload described by `docs/specs/modules/design_reference.md:605-774` by defining a typed grammar in `core/dyn_predictor.rs`, for example `facet::define_attr_grammar! { ns "dsrs"; crate_path $crate::core::dyn_predictor; pub enum Attr { Parameter(Option<&'static PredictAccessorFns>) } }`, and expose a helper to decode `PredictAccessorFns` from `&'static [facet::Attr]`. Exporting this module from `core/mod.rs` makes the walker and `Predict` implementations reachable to other crates.

2. Upgrade `Predict<S>` to carry the accessor payload and implement `DynPredictor`.
   - Files: `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:31-535` (struct definition, `forward_untyped`, `MetaSignature`, `Optimizable`).
   - Existing signature(s): `Predict<S>` lives inside `#[derive(facet::Facet)] pub struct Predict<S: Signature> { tools, demos, instruction_override, _marker }` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:31-41`). `forward_untyped` already exists at `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:415-468`, and the `MetaSignature`/`Optimizable` shims still run at `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:471-535`.
   - New signature(s): add `[NEW] const ACCESSOR_FNS: PredictAccessorFns = PredictAccessorFns { accessor: Predict::<S>::accessor };` and `[NEW] fn accessor(value: *mut ()) -> *mut dyn DynPredictor`, then attach the payload with `#[facet(dsrs::parameter = Some(&Self::ACCESSOR_FNS))]` on `Predict<S>`. `Predict<S>` also needs `[NEW] fn dump_state(&self) -> PredictState` / `[NEW] fn load_state(&mut self, state: PredictState) -> Result<()>` that reuse the existing `demo_from_example`/`example_from_demo` helpers (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:312-413`). Add `[NEW] impl<S: Signature + Clone> DynPredictor for Predict<S>` that forwards each method to the typed helpers and reuses `forward_untyped` for the async method (already implemented at `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:415-468`).
   - Required imports: bring `crate::core::{DynPredictor, PredictState}` and the conversion helpers from the surrounding file (`example_from_demo`, `demo_from_example`, `prediction_from_output`). `Predict::builder`, `Demo`, `CallMetadata`, etc., stay untouched.
   - Other changes: keep the `MetaSignature`/`Optimizable` impls as compatibility shims but annotate them as migration debt (they will simply delegate to the new trait so current optimizer tests continue to compile, but the plan should note they are legacy paths slated for removal after V6). This avoids adding new migration scaffolding beyond what is required to keep `cargo test` green while the new flow ships.

3. Implement the F6 walker that returns typed handles.
   - Files: reuse `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/core/dyn_predictor.rs` to host `[NEW] pub fn named_parameters<M>(module: &mut M) -> Result<Vec<(String, &mut dyn DynPredictor)>, NamedParametersError>` plus helper `walk_fields`/`walk_value` that follow `facet::Shape::def` like `Def::Struct` and descend field order exactly as the spec demands (`docs/specs/modules/design_reference.md:546-599`).
   - Existing signature(s): there is no `named_parameters` yet; discovery currently happens via `Optimizable::parameters()` chains such as `ChainOfThought::parameters` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/chain_of_thought.rs:114-135`).
   - New signature(s): `[NEW] pub fn named_parameters<M>(module: &mut M) -> Result<Vec<(String, &mut dyn DynPredictor)>, NamedParametersError> where M: Module + for<'a> Facet<'a>;` with `#[tracing::instrument(level = "debug", name = "dsrs.named_parameters", skip(module))]` to expose predicate counts the same way existing `tracing` annotations do (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:57-205`). The helper will stop whenever it encounters a `Shape` that carries `dsrs::parameter`, append the accumulated dotted path (respecting struct nesting) and the attribute-decoded `PredictAccessorFns`, and return the handle cast to `&mut dyn DynPredictor`. If the recursion encounters a container with `dsrs::parameter` inside a `Vec`, `Option`, or `HashMap`, emit `NamedParametersError::Container` and add a TODO referencing S5 (`docs/specs/modules/breadboard.md:40-54`).
   - Required imports: `use facet::{Def, Field}; use facet::FieldExt; use facet::Shape; use crate::{Facet, Module, DynPredictor};` plus the new attr helpers defined earlier.
   - Other changes: re-export `named_parameters` from `core/mod.rs` so optimizers can call it via `crate::core::named_parameters`. Document in the plan that the walker is intentionally limited to struct fields for V5 and errors on containers so future S5 work can extend it without backtracking.

4. Rewire the optimizer trait and implementations to use the new surface while keeping the current `Evaluator` metric surface as a temporary V5 debt item.
   - Files: modify `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mod.rs:11-24` (trait definition), `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/copro.rs:65-480`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mipro.rs:191-620`, and `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/gepa.rs:360-470` so every optimizer calls `named_parameters` instead of `module.parameters()`. 
   - Existing signature(s): `pub trait Optimizer { async fn compile<M>(&self, module: &mut M, trainset: Vec<Example>) -> Result<()> where M: Module<Input = Example, Output = Prediction> + Optimizable + Evaluator; }` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mod.rs:19-24`). Each optimizer currently looks up predictors via `module.parameters()` before mutating them (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/copro.rs:95-276`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/mipro.rs:191-385`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/optimizer/gepa.rs:446-470`).
   - New signature(s): `[NEW] async fn compile<M>(&self, module: &mut M, trainset: Vec<Example>) -> Result<()> where M: Module<Input = Example, Output = Prediction> + Evaluator + for<'a> Facet<'a>;` (drops `Optimizable`, adds `Facet`, keeps current Example/Prediction evaluator boundary for this slice so optimizer internals can migrate first). Internally each optimizer will call `crate::core::named_parameters(module)?` (or a helper that converts the `Vec` to a `HashMap<String, &mut dyn DynPredictor>` keyed by path) and use `DynPredictor::schema`, `instruction`, `set_instruction`, `demos_as_examples`, `set_demos_from_examples`, and `forward_untyped` instead of the legacy `MetaSignature` helpers. For example, `COPRO` will keep the existing instruction candidate loop but now calls `predictor.schema().output_fields()` instead of `predictor.get_signature().output_fields()`, and use `predictor.set_instruction(...)` via the new trait. The container of `ChainOfThought` `Optimizable` code is now unused by the new walker but remains as a migration debt shim until V6 (per `ChainOfThought::parameters` at `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/modules/chain_of_thought.rs:114-135`).
   - Required imports: add `use crate::core::{DynPredictor, named_parameters};` at the top of each optimizer file, keep `Example`, `Prediction`, `Evaluator` imports for the existing evaluation loops, and ensure `tracing` macros continue to report predictor counts.
   - Other changes: arbitration outcome for this slice is to keep `Evaluator` as the `metric` provider because it already wraps `forward_all_with_progress` (`/Users/darin/src/personal/DSRs/crates/dspy-rs/src/evaluate/evaluator.rs:1-34`), so U50 is satisfied via `Evaluator::metric` without adding a parallel callback argument. This is explicitly logged as migration debt against C4 typed-evaluator replacement, which is deferred to post-V5 cleanup to avoid duplicative churn while F6/F8 land.

5. Ship regression coverage and validation notes for the new surface.
   - Files: add `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_named_parameters.rs`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_named_parameters_containers.rs`, `/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_dyn_predictor_forward_untyped.rs` (all [NEW]); optionally update `docs/specs/modules/breadboard.md`/`docs/specs/modules/design_reference.md` to reference the actual implementation once it ships.
   - Existing signature(s): no tests currently cover `named_parameters`/`DynPredictor`; the only optimizer discovery tests still rely on `Optimizable` derives (`/Users/darin/src/personal/DSRs/crates/dspy-rs/tests/test_optimizable.rs`).
   - New signature(s): `[NEW] async fn named_parameters_chain_of_thought()` verifies `named_parameters` returns `("predictor", _)` for `ChainOfThought` and that mutating the handle’s instruction via `DynPredictor::set_instruction` changes the module’s output. `[NEW] fn named_parameters_container_error()` constructs a small `Facet` struct whose `Vec<Predict<_>>` field triggers `NamedParametersError::Container`. `[NEW] async fn dyn_predictor_forward_untyped_returns_baml()` asserts that `DynPredictor::forward_untyped` delivers `Predicted<BamlValue>` and preserves `CallMetadata` (reusing `Predict::forward_untyped` from `/Users/darin/src/personal/DSRs/crates/dspy-rs/src/predictors/predict.rs:415-468`).
   - Required fixtures: reuse `ChainOfThought::<QA>::new()` for the positive test, a tiny `#[derive(Facet)] struct Container { list: Vec<Predict<QA>> }` for the container error, and a canned `BamlValue` (built from `QAInput::try_from_baml_value`) for the untyped-forward test.
   - Other changes: document in the plan and tests that container errors follow `docs/specs/modules/breadboard.md:144-147`, so the error contains the offending `Vec`/`Option`/`HashMap` type and path, and leave a TODO referencing S5 for when container traversal becomes allowable.

### Test Plan
1. `test_named_parameters_chain_of_thought` (`crates/dspy-rs/tests/test_named_parameters.rs`) — asserts `named_parameters(&mut ChainOfThought::<QA>::new())` returns a single path `"predictor"` whose handle can `set_instruction`/`instruction` and whose demos modify the underlying `Predict`. Setup: construct `ChainOfThought::<QA>::new()`, call `named_parameters`, mutate the first handle, run one forward pass, and verify the instruction override took effect. Expectation: walker returns the expected path, and the mutated instruction is reflected in the final prediction metadata.
2. `test_named_parameters_container_error` (`crates/dspy-rs/tests/test_named_parameters_containers.rs`) — asserts the walker returns `NamedParametersError::Container { path, ty }` when encountering a `Vec<Predict<_>>` field; the path should mention the struct field name per the deterministic grammar, and `ty` should identify `Vec`. Setup: define a small `#[derive(Facet)] struct Container { #[facet(skip, opaque)] tools: Vec<Arc<dyn ToolDyn>>; predictions: Vec<Predict<QA>> }` (with the second field carrying `dsrs::parameter` through `Predict`) and call `named_parameters` to trigger the error. Expectation: the error variant is returned rather than a panic, satisfying the S5 constraint.
3. `test_dyn_predictor_forward_untyped_returns_baml` (`crates/dspy-rs/tests/test_dyn_predictor_forward_untyped.rs`) — asserts that calling `forward_untyped` on a `DynPredictor` handle returns `Predicted<BamlValue>` whose metadata matches the typed `Predict` call. Setup: reuse the `named_parameters` call from test 1, build a `BamlValue` via `QAInput::try_from_baml_value`, and call `forward_untyped`. Expectation: the result contains `BamlValue` output, the metadata’s `CallMetadata::raw_response` is non-empty, and `Predicted::metadata()` matches the typed call’s metadata, proving the trait forwards correctly.
