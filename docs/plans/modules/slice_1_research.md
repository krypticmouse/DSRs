# Slice 1 Research (V1 Typed Call)

## Requirements Checklist (V1)
- Provide the typed signature path that F1/F12 call for: `#[derive(Signature)]` must keep generating `Input`/`Output` helper types, carry docs as instructions, and keep signature structs aligned with user fields so P1 users only change the type to swap strategies (breadboard U1–U5, shapes F1, design reference §2–§4, docs/specs/modules/shapes.md:51-200, docs/specs/modules/design_reference.md:46-355).
- Replace the legacy `FieldSpec` vectors with a Facet-derived `SignatureSchema` cache (S1/S6 decision) so every `SignatureSchema::of::<S>()` call is idempotent and shared across Places (breadboard architectural invariant S1 plus shapes F2 and design reference §3, docs/specs/modules/breadboard.md:36-80, docs/specs/modules/shapes.md:51-200, docs/specs/modules/design_reference.md:149-229, docs/specs/modules/spikes/S6-migration-fieldspec-to-signatureschema.md:1-139).
- Keep `Predict` as the leaf parameter with demos, instruction overrides, and tools, and return a single `CallOutcome<Output>` that carries result vs metadata so adapters and module consumers (including batch helpers) can reason about success, LM usage, and parse context (breadboard U6–U10, U48, shapes F4/F5/F7, design reference §5–§8, docs/specs/modules/breadboard.md:71-200, docs/specs/modules/shapes.md:57-67, docs/specs/modules/design_reference.md:359-672).
- Provide adapter building blocks (`ChatAdapter::build_system`, `format_input/output`, `parse_sections`, `parse_output`) that consume `SignatureSchema` so typed and optional dynamic paths render/parse identical prompts and maintain flatten-aware field navigation (shapes F7, design reference §8, docs/specs/modules/shapes.md:63-67, docs/specs/modules/design_reference.md:576-672).
- Leave the Module trait minimal and async, with `forward(&self, input) -> CallOutcome<Output>` so combinators like `BestOfN`, `ChainOfThought`, and any user-defined module remain swappable without extra API surface (breadboard N8, U9, shapes F4, design reference §5, docs/specs/modules/breadboard.md:137-208, docs/specs/modules/shapes.md:57-67, docs/specs/modules/design_reference.md:359-399).

## Type and Schema Definitions to Ship in Slice 1
1. **Signature trait & derive surface (F1/F12):** `Signature` stays `Send + Sync + 'static` and bounds `S::Input`/`S::Output` with `BamlType + Facet + Send + Sync`, but the new derive must stop emitting static `FieldSpec` arrays. The derive still yields public `Input`/`Output` helper structs with doc comments turned into LM instructions so the adapter can display helpful prompts (design reference §2, lines 48-124, docs/specs/modules/design_reference.md:46-124). Generic parameters and `#[flatten]` fields flow through thanks to the new facet-aware schema.
2. **SignatureSchema + Field/Path metadata (F2):** `SignatureSchema` contains `instruction`, ordered `input_fields` / `output_fields`, plus an `output_format: Arc<OutputFormatContent>`. Each `FieldSchema` holds the LM-visible name, the Rust identifier, `TypeIR`, a pointer to its `Shape`, the `FieldPath` (e.g. `["inner", "answer"]`), docs, constraints, and format hints so `format_input/output` and `parse_output` can navigate flattened layouts (design reference §3, lines 149-229, docs/specs/modules/design_reference.md:149-229).
3. **Module and CallOutcome (F4/F5):** `Module` is an `async_trait` whose `forward` returns `CallOutcome<Self::Output>`; `CallOutcome` itself encapsulates a `Result` plus raw LM content, usage, tool calls/executions, and field parse metadata. `Predict<S>` is the Slice 1 leaf implementation, and `Demo` moves to typed pairs `{ input: S::Input, output: S::Output }` (design reference §5, lines 359-399, §6, lines 402-503, docs/specs/modules/design_reference.md:359-503).
4. **ChatAdapter building blocks (F7):** Public methods `build_system`, `format_input`, `format_output`, `parse_sections`, and `parse_output::<O>` consume `SignatureSchema`, walk `BamlValue` through `FieldPath`, and support flatten-aware navigation and coercion via `jsonish::from_str` (design reference §8, lines 576-672, docs/specs/modules/design_reference.md:576-672).

### Out of Scope for Slice 1 (but constraints to preserve)
- **F3 augmentation wrappers and ChainOfThought surfaces** are Slice 2, so Slice 1 changes must not preclude wrapper flatten/deref behavior.
- **F8 DynPredictor and optimizer-facing API** are Slice 5, so Slice 1 should keep the call pipeline compatible with later type-erased bridging but does not implement optimizer migration now.

## Existing Code Patterns to Extend or Replace
1. **Signature derive & FieldSpec plumbing:** `crates/dsrs-macros/src/lib.rs` still emits `BamlType` helper structs, static `__FOO_INPUT_FIELDS`/`__FOO_OUTPUT_FIELDS`, and implements `Signature` with `input_fields()`, `output_fields()`, `output_format_content()`, plus the old `from_parts`/`into_parts` round-trip (`crates/dsrs-macros/src/lib.rs:22-691`). This table-driven metadata must be rewritten to build `SignatureSchema` from facet shapes instead of static arrays (see S1 plan lines 86-135, docs/specs/modules/spikes/S1-generic-signature-derive.md:85-135).
2. **Typed runtime still uses `FieldSpec` + `CallResult`:** The core `Signature` trait (`crates/dspy-rs/src/core/signature.rs:6-50`) expects `FieldSpec` arrays and the macro bridge produces them; `CallResult<O>` is the only typed return container right now (`crates/dspy-rs/src/core/call_result.rs:6-79`). `Predict<S>` stores `Vec<S>` demos, calls `ChatAdapter::format_*_typed`/`parse_response_typed`, and produces `CallResult<S>` via `CallResult::new(...)` (`crates/dspy-rs/src/predictors/predict.rs:18-190`). The typed path therefore lacks `CallOutcome`, flatten-aware schema, and `SignatureSchema` (search for `SignatureSchema` in the workspace returns only docs), so this entire pipeline is the main rewrite target.
3. **ChatAdapter typed/legacy wiring:** `ChatAdapter::format_*_typed`/`parse_response_typed` currently iterate `Signature::input_fields()` / `output_fields()` and pull values by `rust_name` from flattened `BamlValue`s, then reconstruct `S::Output` directly (`crates/dspy-rs/src/adapter/chat.rs:193-755`). The same file also still implements the legacy `MetaSignature` path (`format_system_message`, `format_demos`, adapter trait, etc.; see `crates/dspy-rs/src/adapter/mod.rs:1-24`, `crates/dspy-rs/src/adapter/chat.rs:295-824`). That code assumes top-level field names and the `MetaSignature` trait, which `Predict<S>` currently exposes for optimizer/legacy compatibility (`crates/dspy-rs/src/predictors/predict.rs:443-478`). Removing the legacy path after introducing schema-derived metadata is possible because all existing adapters reference this trait surface.
4. **Module/optimizer surface still depends on MetaSignature:** `Optimizable` trait and optimizers use `MetaSignature` and `FieldSpec` (`crates/dspy-rs/src/core/module.rs:7-99`, `crates/dspy-rs/src/optimizer/mipro.rs:491`, `crates/dspy-rs/src/optimizer/copro.rs:73-225`). That wiring must be replaced once `DynPredictor` and schema-derived metadata exist, consistent with the S6 conclusion that there is no incremental migration (docs/specs/modules/spikes/S6-migration-fieldspec-to-signatureschema.md:1-139).

## Spec Ambiguities / Decisions Needed
- **Alias/constraint semantics for flattened leaves:** S1 flagged that it is unclear how sibling names or alias overrides should behave when flattened fields share LM-visible names (`docs/specs/modules/spikes/S1-generic-signature-derive.md:121-135`). We need a concrete rule for naming collisions (e.g., always prefix with path, forbid duplicates) and for whether constraints on inner fields migrate to the flattened accessor or stay on the wrapper.
- **CallOutcome ergonomics:** The high-level docs describe `CallOutcome` as `Result + metadata` with `Try`/`Deref` helpers, but we still need to choose a Rust-friendly shape (builder, error propagation, conversion to `Result`, and whether `CallOutcome::from_error` clones the raw LM response or keeps an Arc) before implementing (design reference §5, lines 359-399, §6 lines 402-503, docs/specs/modules/design_reference.md:359-503).
- **Facet flatten bookkeeping:** S8 verified `field.is_flattened()` and `field.shape()` exist, but noted that `bamltype::schema_builder` and `convert::build_object_fields` currently ignore the flag (`docs/specs/modules/spikes/S8-facet-flatten-metadata.md:53-69`). Slice 1 must decide whether to patch those helper routines or wrap them with new stack-based walkers so the new `SignatureSchema` correctly recurses through flatten flags.
- **MetaSignature / Optimizable retirement timeline:** S6 concluded that the entire `FieldSpec`/`MetaSignature`/`LegacyPredict` surface is deleted (docs/specs/modules/spikes/S6-migration-fieldspec-to-signatureschema.md:85-140), yet optimizer code still depends on it. We need to document the exact migration crunch: which optimizers move to `DynPredictor`, how existing examples are updated, and what tests certify the drop of legacy traits.

## Recommended Implementation Approach
1. **Ship `SignatureSchema` + caching (S1/S6):** Introduce the type described in design reference §3 with `FieldPath`, walker helpers, and an `OnceLock` per `TypeId`. Reuse `field.is_flattened()` per S8 to flatten nested layouts. Provide helpers (e.g., `navigate_path`, `insert_at_path`, `baml_value_fields`) so the typed adapter can reuse them later (`docs/specs/modules/design_reference.md:149-229`, `docs/specs/modules/spikes/S1-generic-signature-derive.md:86-135`, `docs/specs/modules/spikes/S8-facet-flatten-metadata.md:1-69`).
2. **Rewrite the derive macro:** Switch `crates/dsrs-macros/src/lib.rs` to generate schema metadata via facet shapes, thread generics, preserve constraints/format info, and emit `#[facet(dsrs::flatten)]` when `#[flatten]` is used (S1 steps 1-3, docs/specs/modules/spikes/S1-generic-signature-derive.md:86-135). Remove static `FieldSpec` arrays from the runtime path, or keep them behind a temporary compatibility shim that immediately delegates to the new schema while tests still rely on the old trait (if absolutely necessary).
3. **Adjust the Signature trait/CallOutcome plumbing:** Update `crates/dspy-rs/src/core/signature.rs` so `Signature` no longer exposes `input_fields`/`output_fields`/`output_format_content` but instead exposes `instructions()` (plus whatever fee we need) and let `SignatureSchema::of::<S>()` supply the rest via the new derive. Introduce `CallOutcome` in `core/call_result.rs` (or a new module) replicating the design reference semantics with constructors `from_parts`, `ok`, `from_error`, and helper accessors. Deprecate `CallResult`/`CallResult::new` by either replacing or wrapping it until tests transition.
4. **Update Predict/module implementations:** Modify `Predict<S>` (`crates/dspy-rs/src/predictors/predict.rs`) to store `Vec<Demo<S>>` and rely on the new adapter pipeline. Its `call` should now await and return `CallOutcome<S::Output>` by constructing it from the schema-aware parsing stage, wrapping LM errors via `PredictError::Lm` or `PredictError::Parse`. `DynPredictor` implementations should return `CallOutcome<BamlValue>` for `forward_untyped`. Make sure `Optimizable`/`MetaSignature` bindings drop or wrap to the new `DynPredictor` handles.
5. **Schema-aware adapter:** Replace `ChatAdapter` typed helpers so they iterate `SignatureSchema::input_fields/output_fields`, use `FieldPath` to `navigate_path`/`insert_at_path`, and leverage `jsonish::from_str` + `BamlType::try_from_baml_value` to reconstruct typed outputs (`docs/specs/modules/design_reference.md:576-672`). Keep `format_schema_for_prompt`, `parse_sections`, and constraint enforcement, but feed them schema-derived names to stay flatten-aware. Once this typed path is stable, the legacy `MetaSignature` branch can be removed (per S6); otherwise, provide a short-term fallback that keeps `MetaSignature` behavior by projecting the new schema into JSON.
6. **Testing/regression plan:** Add positive tests for generic + flattened signatures (both macro and adapter), flatten-aware parse/format round trips, constraint/alias coverage, and `CallOutcome` metadata (S1 acceptance). Keep `cargo test -p dsrs_macros --tests` plus new `dspy-rs` typed adapter tests. Defer optimizer migration test rewrites to later slices and document that explicitly in Slice 1 plan.

## Readiness
- **Ready:** The specs already nail down the required types/flow (breadboard invariants, shapes parts, design reference, S1/S6/S8 decisions). We also have a working macro plus adapter/predictor code that can be rewired; the ideal change touches `crates/dsrs-macros/src/lib.rs`, `crates/dspy-rs/src/core`, `crates/dspy-rs/src/predictors/predict.rs`, and `crates/dspy-rs/src/adapter/chat.rs` with precise line references above.
- **Blocked until:** the new `SignatureSchema` + `CallOutcome` shapes are coded, flatten-aware walkers are patched in `bamltype`, and we decide how to retire `FieldSpec`/`MetaSignature` without breaking optimizer tests (S6 sink). Without those structural pieces, typed calls still rely on legacy metadata and cannot satisfy the breadboard V1 invariants.
