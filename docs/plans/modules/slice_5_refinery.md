Spec fidelity – FAIL
- Plan nails the core F6/F8 pieces specified in the breadboard (U30→N18 discovery, U31 handles, U32–U37 DynPredictor calls) and the design reference instructions for `PredictAccessorFns`, `named_parameters`, and the trait shape walking, which keeps the new surface aligned with the layered architecture. However, the V5/C4 requirement recorded in `docs/plans/modules/phase_4_5_cleanup_kickoff.md:62` says the typed evaluator surface must replace the legacy `Evaluator: Module<Input=Example, Output=Prediction>` contract. The current plan still depends on that trait and the old Example/Prediction bounds for `Optimizer::compile` while keeping `Evaluator` as the metric hook. That gap needs arbitration: do we evolve `Evaluator` as part of Slice 5 or leave the switchover to the post-V5 kill pass?

Shape compliance – PASS
- The plan follows the shape-driven logic spelled out in the design reference: the walker recurses over `facet::Shape::def` structs only, stops at `dsrs::parameter`, emits dotted paths, and errors on containers (`Vec/Option/HashMap`) per the S5 deferral contract, with a `NamedParametersError` that surfaces the offending path/type. It also wires `Predict` to the attribute grammar described around doc lines 605‑774 so `PredictAccessorFns` is stored in the shape metadata, satisfying the S2 Mechanism A expectations for typed attr payloads.

Breadboard consistency – PASS
- Slice 5 is explicitly the optimizer interface (F6+F8) in the breadboard, and the plan keeps that flow: Step 1 defines the DynPredictor bridge, Step 3 exposes `named_parameters` (U30) via `Facet` reflection, Step 4 rewires optimizers to use the new handles while preserving the P1→P3 `optimizer.compile(&mut module, trainset, metric)` entry (U50). The plan also documents the container error contract (breadboard N18/N21–N23) and ties the tests to the narrative (container error test referencing S5, forward_untyped test for N23).

Sequencing – PASS
- The order is logical: establish the new helper module (Step 1), upgrade `Predict` to implement `DynPredictor` (Step 2), then add the walker (Step 3) before touching the optimizer wires (Step 4), and finally layer regression tests (Step 5). Each step builds on the previous outputs so there are no hidden dependencies or mid-flight rewrites.

API design – FAIL
- While the plan modernizes the optimizer discovery surface, it still leaves `Optimizer::compile` bounded to `Module<Input = Example, Output = Prediction>` and the legacy `Evaluator` trait. That contradicts the C4/Iv5 edict in `phase_4_5_cleanup_kickoff.md:62`, which says the typed evaluator surface should replace that trait. We need a clear decision on whether Slice 5 must introduce the new typed evaluator interface (and, if so, how the metric hook is surfaced) or if that substitution remains a later cleanup. Without that decision the API design remains inconsistent with the documented goal.

Over-engineering – PASS
- The plan intends to keep migrations minimal (legacy `MetaSignature`/`Optimizable` shims marked as debt and untouched beyond necessary stubs) and avoids fascicle container traversal until a concrete use case appears, matching the breadboard encouragement to favor the shortest correct path. The new tests target only the required contract (struct-field discovery, container error, forward_untyped metadata), so there is no unnecessary scaffolding or speculative wiring.
