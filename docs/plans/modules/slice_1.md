# Slice 1 Plan (V1 Typed Call)

## Simplified Goal
Ship the V1 typed call path with **facet-derived `SignatureSchema`**, the new **`CallOutcome<O>`** return surface, and schema-aware `ChatAdapter`/`Predict` plumbing. Focus strictly on the typed call surface (no augmentation/optimizer rewrites). Any compatibility shim is temporary compile support only, and must not become a parallel long-term API surface.

## Execution Order (to minimize compile breakage)
1. Add the new schema & outcome core primitives (`schema.rs`, `call_outcome.rs`) and re-export them so the rest of the tree can build on the new types without touching downstream code.
2. Update `core::{Signature, module, mod}` and `lib.rs` to refer to the new primitives, keeping `FieldSpec`/`MetaSignature`/`CallResult` as deprecated shims that forward to the schema/outcome for compatibility.  This keeps existing modules/tests compiling while we migrate the typed path.
3. Rewrite the macro (`crates/dsrs-macros/src/lib.rs`) so `#[derive(Signature)]` emits `SignatureSchema::of::<S>()` builders (plus optional retrofitted `FieldSpec` arrays for the legacy ABI) and `CallOutcome` constructors for helper APIs.
4. Rewire `ChatAdapter` to format/parse via `SignatureSchema`/`FieldPath` (replace every `input_fields()`/`output_fields()` use) and expose helpers that `Predict` can rely on.
5. Rewrite `Predict<S>` and the `Module` contract to await `CallOutcome`, use the new adapter entrypoints, and keep metadata in sync so any LM/parse failure still carries `CallMetadata`.
6. Extend the test suite with typed schema + call-outcome coverage so Slice 1 has concrete assertions, then delete or flag now-redundant legacy assertions once the shim validations land.

## File-by-file Plan

### crates/dspy-rs/src/core/schema.rs _(new file)_
- Imports: `use std::{any::{Any, TypeId}, sync::OnceLock}; use std::sync::Arc; use bamltype::{jsonish::TypeIR, internal_baml_jinja::types::OutputFormatContent, schema::{Shape, Field}}; use crate::{ConstraintSpec, ConstraintKind};` (adjust real paths to where `Shape` lives).
- Add `pub struct FieldPath { parts: Vec<&'static str> }` with constructors `pub fn new(parts: impl IntoIterator<Item=&'static str>) -> Self` and helpers `pub fn push(&mut self, part: &'static str)` plus `pub fn iter(&self) -> impl Iterator<Item=&'static str> + '_` and `pub fn display(&self) -> String` for debugging.
- Add `pub struct FieldSchema { pub lm_name: &'static str, pub rust_name: &'static str, pub docs: &'static str, pub type_ir: TypeIR, pub shape: fn() -> &'static Shape, pub path: FieldPath, pub constraints: &'static [ConstraintSpec], pub format: Option<&'static str> }`.
- Add `pub struct SignatureSchema { instruction: &'static str, input_fields: Box<[FieldSchema]>, output_fields: Box<[FieldSchema]>, output_format: Arc<OutputFormatContent> }` plus `pub fn instruction(&self) -> &'static str`, `pub fn input_fields(&self) -> &[FieldSchema]`, `pub fn output_fields(&self) -> &[FieldSchema]`, `pub fn output_format(&self) -> &OutputFormatContent` along with `pub fn navigate_field(&self, path: &FieldPath, root: &bamltype::BamlValue) -> Option<&bamltype::BamlValue>` helpers that `ChatAdapter` can reuse.
- Implement `impl SignatureSchema { pub fn of<S: Signature>() -> &'static Self }` using a TypeId-keyed cache (e.g., a `OnceCell<HashMap<TypeId, &'static SignatureSchema>>` or a `Mutex<HashMap>` guarded by a `OnceCell`) so we get a unique `OnceLock<SignatureSchema>` per `S` instead of the single-`OnceLock` trap noted in S1. Internally call a `SignatureSchemaBuilder` type (either in this file or a `core/schema/builder.rs`) that runs `S::input_shape()`/`S::output_shape()` (generated by the macro) to produce ordered `FieldSchema` instances with flattened `FieldPath`s (use the `Facet` flatten flag to skip or merge levels).
- Flatten alias and constraint rule (arbitrated): keep `lm_name = alias_or_field_name` for each emitted leaf; require uniqueness of `lm_name` across each side of the schema (`input_fields`, `output_fields`). If duplicates appear after flattening, fail schema construction with a deterministic error that reports both colliding paths. Constraints/format metadata are attached to the emitted flattened leaf `FieldSchema` and reported under that leaf path.
- Provide helper methods `pub fn field_by_rust<'a>(&'a self, rust_name: &str) -> Option<&'a FieldSchema>` (used by metadata collection) and `pub fn field_paths(&self) -> impl Iterator<Item=&FieldPath>`.

### crates/dspy-rs/src/core/signature.rs
- Keep `ConstraintSpec` + `ConstraintKind` (they feed the schema metadata) but remove `FieldSpec` and `MetaSignature` definitions from this file; move them to a new `_legacy.rs` module if needed so the public API stays available.  Use `pub mod legacy` re-export later if we want to keep compatibility names.
- Redefine the `Signature` trait as:
  ```rust
  pub trait Signature: Send + Sync + 'static {
      type Input: BamlType + Facet + Send + Sync;
      type Output: BamlType + Facet + Send + Sync;
      fn instruction() -> &'static str;
      fn schema() -> &'static SignatureSchema;
  }
  ```
  (The `schema()` method just calls `SignatureSchema::of::<Self>()`, but keep it as a trait hook so the macro can stub `SignatureSchemaBuilder::init`).
- Add `pub fn input_shape() -> &'static Shape` / `pub fn output_shape() -> &'static Shape` helper signatures; the derive macro will generate them and the schema builder needs direct access to `Shape` for flatten/constraint flags.
- Keep a `pub trait SignatureExt` if necessary for helper accessors (like `fn format_instruction() -> &'static str`), but keep overload minimal to avoid new API surfaces.

### crates/dspy-rs/src/core/call_outcome.rs _(new file replacing call_result.rs blocks)_
- Move to `crate::core::call_outcome` and define:
  ```rust
  pub struct CallMetadata {
      pub raw_response: String,
      pub lm_usage: LmUsage,
      pub tool_calls: Vec<ToolCall>,
      pub tool_executions: Vec<String>,
      pub node_id: Option<usize>,
      pub field_meta: IndexMap<String, FieldMeta>,
  }

  pub enum CallOutcomeErrorKind {
      Lm(LmError),
      Parse(ParseError),
      Conversion(ConversionError, BamlValue),
  }

  pub struct CallOutcomeError {
      pub metadata: CallMetadata,
      pub kind: CallOutcomeErrorKind,
  }

  pub struct CallOutcome<O> {
      metadata: CallMetadata,
      result: Result<O, CallOutcomeErrorKind>,
  }
  ```
  (Decide whether to keep `FieldMeta`/`ConstraintResult` definitions here or in another module; reuse the existing structs from `call_result.rs` so tests keep compiling.)
- Add constructors:
  ```rust
  impl<O> CallOutcome<O> {
      pub fn ok(output: O, metadata: CallMetadata) -> Self;
      pub fn err(kind: CallOutcomeErrorKind, metadata: CallMetadata) -> Self;
      pub fn metadata(&self) -> &CallMetadata;
      pub fn into_result(self) -> Result<O, CallOutcomeError>;
      pub fn try_into_result(self) -> Result<O, CallOutcomeError>; // used by Try impl
  }
  ```
  where `CallOutcomeError` takes ownership of the metadata in the error branch.
- `Try` strategy (arbitrated): implement `Try`/`FromResidual` for `CallOutcome<O>` under nightly (`#![feature(try_trait_v2)]`) because the repo toolchain is nightly; also provide `into_result()` as the stable explicit conversion API for call sites that do not rely on `?`.
- Implement `impl<O> std::ops::Deref for CallOutcome<O>` pointing to `Result<O, CallOutcomeErrorKind>` and `impl<O> std::ops::DerefMut` if needed so adapters can use `?`. Implement `impl<O> std::ops::Try for CallOutcome<O>` (with nightly guard? check toolchain; if `try_trait_v2` unavailable, provide `impl From<CallOutcome<O>> for Result<O, CallOutcomeError> { ... }`). Document fallback in plan (e.g., wrap `call_outcome.rs` with `#[cfg(feature = "try_trait_v2")]`?).
- `CallMetadata` should remain sharable; expose `pub fn field_meta(&self) -> &IndexMap<String, FieldMeta>` for downstream uses. Ensure `CallOutcomeErrorKind::Parse` includes the `ParseError` so existing logic for `PredictError::Parse` can be re-used.

### crates/dspy-rs/src/core/module.rs
- Update the `Module` trait: `async fn forward(&self, inputs: Example) -> CallOutcome<Prediction>;` and keep `forward_untyped` returning `CallOutcome<BamlValue>` (wrap conversion errors inside `CallOutcomeErrorKind::Conversion`). Remove the `Result` return so the new default surface is `CallOutcome` everywhere. Keep the `batch` helper unchanged but adjust error handling to unwrap via `?` on `CallOutcome`.
- Keep `Optimizable` trait as-is (it still references `MetaSignature`) but add a comment in the plan noting how future slices will replace those callers with schema-based discovery.

### crates/dspy-rs/src/lib.rs
- Re-export the new `core::call_outcome::{CallOutcome, CallOutcomeError, CallMetadata}` and the `SignatureSchema` module so downstream crates can use them: add `pub use core::schema::*; pub use core::call_outcome::*;`.
- Keep deprecated `CallResult`/`MetaSignature` exports by re-exporting them from a `pub mod legacy` that reuses the schema/outcome types internally. Clearly document in the plan that these re-exports exist only for backwards compatibility and will be trimmed in a later slice.

### crates/dspy-rs/src/core/mod.rs
- Replace `mod call_result;` with `mod call_outcome;` and `mod schema;` and re-export the new symbols: `pub use call_outcome::{CallOutcome, CallOutcomeError, CallMetadata}; pub use schema::{SignatureSchema, FieldSchema, FieldPath};`.
- Keep `pub use call_result::{CallResult, ConstraintResult, FieldMeta};` but annotate with `#[deprecated]`/`#[cfg_attr]` (if practical) and have the old `CallResult` now delegate to `CallOutcome` so existing callers continue to compile while we migrate them.

### crates/dspy-rs/src/adapter/chat.rs
- Replace every `Signature::input_fields()`/`output_fields()` call with `schema.input_fields()`/`schema.output_fields()` where `let schema = S::schema()` (typed path). Introduce helpers `fn insert_baml_at_path(root: &mut BamlMap, path: &FieldPath, value: BamlValue)` and `fn value_for_path(root: &BamlValue, path: &FieldPath) -> Option<&BamlValue>` backed by `SignatureSchema` to support flatten-aware navigation.
- Replace `parse_response_typed` to iterate over `schema.output_fields()`, use `jsonish::from_str` along with `field.shape()`/`field.path()` to parse each section, collect `FieldMeta`, and build the output `BamlValue` by writing at the recorded `FieldPath`s.
- Update formatting helpers (`format_system_message_typed`, `format_user_message_typed`, `format_assistant_message_typed`, `format_field_structure_typed`) to use `field.lm_name` and `field.path()` for prompts instead of legacy `FieldSpec`. Update logging fields (e.g., `output_field_count`) to use `schema.output_fields().len()`.
- Provide new `pub fn parse_response_with_schema<S: Signature>(...) -> Result<(S::Output, CallMetadata), CallOutcomeErrorKind>` that the typed `Predict` can call, so parsing errors are already wired into `CallOutcome` metadata. This method should no longer take `Message` by reference but by value if needed to preserve ownership.

### crates/dspy-rs/src/predictors/predict.rs
- Replace `call_with_meta`/`CallResult` with a single `pub async fn call(&self, input: S::Input) -> CallOutcome<S::Output>` that:
  1. Builds prompts via the schema-aware `ChatAdapter` helpers.
  2. Calls the LM, captures `raw_response`, `lm_usage`, `tool_calls`, `tool_executions`, and `node_id` exactly as before.
  3. Calls the new schema parser, returns `(S::Output, IndexMap<String, FieldMeta>)` and records any constraints/checks into `CallMetadata`.
  4. Constructs `CallOutcome::ok(typed_output, metadata)` on success or `CallOutcome::err(CallOutcomeErrorKind::Parse(err), metadata)` on failure; LM failures become `CallOutcome::err(CallOutcomeErrorKind::Lm(err), metadata)` with metadata still carrying `raw_response`/`lm_usage`.
- Store demos as a `Vec<Demo<S>>` (typed `{ input: S::Input, output: S::Output }` pairs) and have the builder accept `Demo<S>` so augmented outputs keep their extra fields without needing `S::from_parts`/`into_parts`.
- Keep `PredictBuilder` structurally the same but update it to push typed `Demo<S>` values and expose typed helpers when needed.
- Ensure `Predict` carries the `#[facet(dsrs::parameter)]` attribute with a `PredictAccessorFns` payload that points at the new schema-aware entrypoints (`CallOutcome`, `dyn DynPredictor`, `SignatureSchema::of::<S>()`). This keeps the F6 walker (S2) discovery working without change.
- Update `Predict` to still implement `DynPredictor` (for future slices) but adjust the trait to return `CallOutcome<BamlValue>` for `forward_untyped` so metadata stays consistent with typed leaves and `schema()`/`instruction()` come from the derive.

### crates/dsrs-macros/src/lib.rs
- Extend the `#[derive(Signature)]` implementation to:
  1. Read doc comments from the struct and field attributes and create a `'static` `&'static str` instruction string.
  2. Emit helper `fn input_shape() -> &'static Shape` / `fn output_shape() -> &'static Shape` referencing the `Facet` `Shape` nodes of the derived `Input`/`Output` types. Keep the existing helper structs (`Input`/`Output`) but ensure they still implement `BamlType`/`Facet` and share constraints/`#[flatten]` with the original fields.
  3. Generate a `static ONCE: OnceLock<SignatureSchema>` plus `impl Signature for Struct` where `fn schema() -> &'static SignatureSchema { SignatureSchema::of::<Self>() }` and `fn instruction() -> &'static str { INSTRUCTION }`.
  4. Optionally generate the old `static __FOO_INPUT_FIELDS`/`__FOO_OUTPUT_FIELDS` arrays and `impl MetaSignature` by folding the schema into JSON if the backwards-compatibility feature gate is enabled, but mark those helpers as deprecated and simple wrappers so we can delete them once legacy modules are gone.
- Update the macro tests to assert that the generated schema includes the expected flattened paths/constraints (mirror the new plan tests) and that `Signature::schema()` is usable from other crates.

### Adapter/Example test files
- Replace the current `crates/dspy-rs/tests/test_adapters.rs` and `tests/test_predictors.rs` expectations so they exercise the schema-based formatting/parsing. Use small fixtures (e.g., `#[derive(Signature)] struct FlattenSig { #[input] pub question: String, #[output] pub meta: Meta }`) to confirm formatting uses `FieldPath` markers and parsing rehydrates `S::Output`.
- Add new tests under `crates/dspy-rs/tests/test_signature_schema.rs` and `crates/dspy-rs/tests/test_call_outcome.rs` that follow the exact assertions listed below in the Test Plan section.

## Migration & Compatibility Handling
- **FieldSpec:** keep the `FieldSpec` struct definition in `core/signature.rs` or a `core/legacy.rs` module but mark it `#[deprecated]`. Provide `impl From<&FieldSchema> for FieldSpec` so we can still build the old arrays inside `MetaSignature` shims without duplicating data. The plan is to keep `MetaSignature`/`LegacyPredict` alive during Slice 1 but have them drive their metadata from the new schema, so we can delete them in Slice 2 without special migration.
- **MetaSignature:** keep the trait but change its implementation for `Predict<S>`/`LegacyPredict` to call `SignatureSchema::of::<S>()` and `schema.field_json()` helpers. Update every `Adapter`/`Optimizer` consumer to use these shims (e.g., `ChatAdapter::format_system_message(&dyn MetaSignature)` now simply serializes `schema` to `serde_json` for compatibility). Document in the plan that once Slice 2 hits optimizer migration we will remove `MetaSignature` by replacing its consumers with schema-based discovery.
- **CallResult:** deprecate `CallResult` by making it a thin wrapper around `CallOutcome` (e.g., `impl<O> From<CallOutcome<O>> for CallResult<O>`). Update the few call sites (e.g., `examples/01-simple.rs`) to use `CallOutcome`. Leave a transitional helper in `core/legacy.rs` so existing user code still compiles until we can cut them in later slices.

## Test Plan
1. `crates/dspy-rs/tests/test_signature_schema.rs`
   - Instantiate `#[derive(Signature)] struct NestedSig` with a flattened inner struct (use `#[flatten]`).
   - Assert `SignatureSchema::of::<NestedSig>().input_fields().iter().map(|f| f.path().iter().copied().collect::<Vec<_>>())` equals `vec![vec!["question"], vec!["detail", "note"]]` and that `output_fields()` contains both the flattened path and the aliased LM names.
   - Assert `SignatureSchema::of::<NestedSig>().output_format().kind()` matches the enum returned by `<NestedSig::Output as BamlType>::baml_output_format().kind()`.
2. `crates/dspy-rs/tests/test_call_outcome.rs`
   - Build a fake `CallMetadata` (dummy `LmUsage`, `tool_calls`, etc.) and call `CallOutcome::err(CallOutcomeErrorKind::Parse(ParseError::MissingField {...}), metadata.clone())`.
   - Assert that `let err = outcome.into_result().unwrap_err();` and that `err.metadata.raw_response == metadata.raw_response` plus `err.kind` matches the parse variant.
   - Assert `let metadata_ref = outcome.metadata();` still works after construction on success via `CallOutcome::ok`, ensuring we can inspect metadata on success as well.
3. `crates/dspy-rs/tests/test_chat_adapter_schema.rs`
   - Use a `DummyLM` (existing test helper) that returns a pre-segmented `Message` with markers for each `FieldSchema::lm_name` and run `ChatAdapter::parse_response_typed::<ExampleSig>(&response)`.
   - Assert the returned `FieldMeta` map keys are the Rust field names and that `CallOutcome::metadata().field_meta.get("answer").unwrap().raw_text` equals the section text.
   - Assert the `CallOutcome` produced by `Predict::call` contains `metadata.tool_calls.len()` matching the fake LM response and that `metadata.has_failed_checks()` is `false` when there are no constraint violations.

## Checklist of Atomic Tasks
- [ ] Create `core/schema.rs` with `FieldPath`, `FieldSchema`, `SignatureSchema`, builder logic, and caching helpers.
- [ ] Introduce `core/call_outcome.rs` defining `CallOutcome`, `CallMetadata`, `CallOutcomeErrorKind`, and their constructors/traits.
- [ ] Update `core/signature.rs`, `core/mod.rs`, and `lib.rs` so `Signature::schema()`/the re-exports point to the new primitives while keeping `FieldSpec`/`MetaSignature`/`CallResult` shims alive.
- [ ] Extend `crates/dsrs-macros/src/lib.rs` to emit `SignatureSchema` builders, `Signature::schema()`, instruction strings, and (optionally legacy) `FieldSpec` arrays.
- [ ] Rewrite `ChatAdapter` typed formatting/parsing to iterate `SignatureSchema` + `FieldPath`, and produce `CallMetadata` that feeds into `CallOutcome`.
- [ ] Replace `Predict::call_with_meta` with a single `call` returning `CallOutcome<S>` and adjust `Module`/`DynPredictor` so their outputs are also `CallOutcome` instances.
- [ ] Update existing tests/examples to import `CallOutcome` (and eventually drop `CallResult`/`call_with_meta`) while adding the new schema + call-outcome assertions described above.
