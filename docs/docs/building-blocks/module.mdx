---
title: 'Modules'
description: 'Compose predictors into multi-step pipelines'
icon: 'circle-nodes'
---

Modules let you compose multiple [predictors](/docs/building-blocks/predictors) and arbitrary Rust logic into reusable units. Any type implementing the `Module` trait is a module.

## What is a module?

- **Purpose:** Encapsulate a multi-step workflow as a single callable unit.
- **Rust shape:** Any type implementing `Module` with `async fn forward(&self, inputs: Example)`.
- **Composition:** Typically holds one or more `Predict<S>` fields and sequences their calls.

## Predict is already a Module

For simple cases, you don't need a wrapper - `Predict<S>` implements `Module`:

```rust
let predict = Predict::<QA>::new();

// Use typed API directly
let output = predict.call(QAInput { question: "...".into() }).await?;

// Or use Module trait (for optimizers, composition)
let prediction = predict.forward(example).await?;
```

## Custom modules

When you need multiple steps or custom logic:

```rust
use dspy_rs::{Module, Predict, Signature, Example, Prediction};

#[derive(Signature, Clone, Debug)]
struct Summarize {
    #[input] text: String,
    #[output] summary: String,
}

#[derive(Signature, Clone, Debug)]
struct Analyze {
    #[input] summary: String,
    #[output] sentiment: String,
    #[output] key_points: Vec<String>,
}

struct SummarizeAndAnalyze {
    summarizer: Predict<Summarize>,
    analyzer: Predict<Analyze>,
}

impl SummarizeAndAnalyze {
    fn new() -> Self {
        Self {
            summarizer: Predict::<Summarize>::new(),
            analyzer: Predict::<Analyze>::new(),
        }
    }
}

impl Module for SummarizeAndAnalyze {
    async fn forward(&self, inputs: Example) -> anyhow::Result<Prediction> {
        // Step 1: Summarize
        let summary_pred = self.summarizer.forward(inputs).await?;
        let summary = summary_pred.data.get("summary").unwrap().as_str().unwrap();

        // Step 2: Analyze (using typed API inside the module)
        let analysis = self.analyzer.call(AnalyzeInput {
            summary: summary.to_string(),
        }).await?;

        // Compose result
        let mut result = Prediction::default();
        result.data.insert("summary".into(), summary.into());
        result.data.insert("sentiment".into(), analysis.sentiment.into());
        result.data.insert("key_points".into(),
            serde_json::to_value(&analysis.key_points)?);

        Ok(result)
    }
}
```

## Typed access inside modules

Inside `forward()`, you can mix the untyped `Example`/`Prediction` interface (required by the trait) with typed `.call()` for cleaner internal logic:

```rust
impl Module for MyModule {
    async fn forward(&self, inputs: Example) -> anyhow::Result<Prediction> {
        // Extract from Example
        let question = inputs.data.get("question").unwrap().as_str().unwrap();

        // Use typed call internally
        let result = self.predictor.call(QAInput {
            question: question.to_string(),
        }).await?;

        // Access typed fields
        println!("{}", result.answer);  // typed!

        // Convert back to Prediction for return
        // ...
    }
}
```

## The Module trait

```rust
pub trait Module: Send + Sync {
    async fn forward(&self, inputs: Example) -> Result<Prediction>;

    // Batch processing with concurrency control
    async fn batch(
        &self,
        inputs: Vec<Example>,
        max_concurrency: usize,
        display_progress: bool,
    ) -> Result<Vec<Prediction>>;
}
```

The `batch` method is provided automatically - it runs `forward` concurrently with a progress bar.

## Design notes

- **State:** Keep predictors and config as struct fields. Use builders for complex initialization.
- **Async:** `forward` is async because it wraps LM calls.
- **Testability:** Modules work with `DummyLM` for testing without network calls.

## Current limitations

<Warning>
**Runtime signature modification is not supported.**

Unlike DSPy where you can do `ChainOfThought(signature)` to dynamically add a reasoning field, DSRs signatures are fixed at compile time.

If you want chain-of-thought style reasoning, add the field explicitly:

```rust
#[derive(Signature, Clone, Debug)]
struct QA {
    #[input]
    question: String,

    #[output]
    reasoning: String,  // add explicitly

    #[output]
    answer: String,
}
```

A more ergonomic pattern for this is being explored.
</Warning>
