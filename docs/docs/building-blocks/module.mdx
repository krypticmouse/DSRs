---
title: 'Modules'
description: 'Compose predictors into multi-step pipelines'
icon: 'circle-nodes'
---

Most of the time, you can chain [predictors](/docs/building-blocks/predictors) directly using the typed API. For more complex composition or optimizer integration, you can implement the `Module` trait.

## Chaining predictors (the simple way)

Just call one predictor, then use its output as input to the next:

```rust
#[derive(Signature, Clone, Debug)]
struct Summarize {
    #[input] text: String,
    #[output] summary: String,
}

#[derive(Signature, Clone, Debug)]
struct Analyze {
    #[input] summary: String,
    #[output] sentiment: String,
    #[output] key_points: Vec<String>,
}

// Chain them together
let summarizer = Predict::<Summarize>::new();
let analyzer = Predict::<Analyze>::new();

let summary = summarizer.call(SummarizeInput {
    text: long_document.into()
}).await?;

let analysis = analyzer.call(AnalyzeInput {
    summary: summary.summary  // output of first becomes input of second
}).await?;

println!("Sentiment: {}", analysis.sentiment);
```

This is fully typed end-to-end.

## Wrapping in a struct

For reusability, wrap predictors in a struct:

```rust
struct SummarizeAndAnalyze {
    summarizer: Predict<Summarize>,
    analyzer: Predict<Analyze>,
}

impl SummarizeAndAnalyze {
    fn new() -> Self {
        Self {
            summarizer: Predict::<Summarize>::new(),
            analyzer: Predict::<Analyze>::new(),
        }
    }

    async fn run(&self, text: String) -> anyhow::Result<Analyze> {
        let summary = self.summarizer.call(SummarizeInput { text }).await?;
        let analysis = self.analyzer.call(AnalyzeInput {
            summary: summary.summary
        }).await?;
        Ok(analysis)
    }
}
```

## The Module trait

`Predict<S>` implements `Module`, which is used by optimizers and batch processing:

```rust
pub trait Module: Send + Sync {
    async fn forward(&self, inputs: Example) -> Result<Prediction>;

    async fn batch(
        &self,
        inputs: Vec<Example>,
        max_concurrency: usize,
        display_progress: bool,
    ) -> Result<Vec<Prediction>>;
}
```

The `batch` method runs `forward` concurrently with a progress bar.

If you need your custom struct to work with optimizers, implement `Module`. Otherwise, the simpler patterns above are usually enough.

## Current limitations

<Warning>
**Runtime signature modification is not supported.**

Unlike DSPy where you can do `ChainOfThought(signature)` to dynamically add a reasoning field, DSRs signatures are fixed at compile time.

If you want chain-of-thought style reasoning, add the field explicitly:

```rust
#[derive(Signature, Clone, Debug)]
struct QA {
    #[input]
    question: String,

    #[output]
    reasoning: String,  // add explicitly

    #[output]
    answer: String,
}
```

A more ergonomic pattern for this is being explored.
</Warning>
