---
title: 'Signatures'
description: 'Define task specifications for LM interactions'
icon: 'pen-to-square'
---

A signature defines the contract for an LM task: what goes in, what comes out, and what instruction to follow.

You write a struct with `#[derive(Signature)]`, mark fields as `#[input]` or `#[output]`, and the macro generates everything needed to work with predictors.

## Basic syntax

```rust
use dspy_rs::Signature;

/// Answer questions accurately and concisely.
#[derive(Signature, Clone, Debug)]
struct QA {
    /// The question to answer
    #[input]
    question: String,

    /// A clear, direct answer
    #[output]
    answer: String,
}
```

That's it. The macro generates `QAInput` which you'll use to call the predictor.

## Docstrings become instructions

Doc comments on your struct and fields turn into the prompt. This is how you tell the LM what to do:

| Source | Becomes |
|--------|---------|
| Struct docstring (`///` above struct) | The main instruction for the LM |
| Field docstrings (`///` above field) | Field descriptions in the prompt |

```rust
/// This becomes the instruction - tell the LM what to do.
#[derive(Signature, Clone, Debug)]
struct MyTask {
    /// This describes what the input is.
    #[input]
    query: String,

    /// This describes what you want the LM to output.
    #[output]
    result: String,
}
```

Better docstrings = better LM behavior. Be specific about what you want.

## Using Rust's type system

You get real types, not string parsing:

```rust
#[derive(Signature, Clone, Debug)]
/// Analyze text for spam detection.
struct SpamAnalysis {
    #[input]
    text: String,

    #[output]
    is_spam: bool,  // actual bool

    #[output]
    confidence: f64,  // actual float

    #[output]
    keywords: Vec<String>,  // actual vec

    #[output]
    category: Option<String>,  // nullable
}
```

**Built-in types** (no extra work needed):
- `String`, `bool`
- `i8`, `i16`, `i32`, `i64`, `f32`, `f64`
- `Option<T>`, `Vec<T>`, `HashMap<String, T>`

## Custom types

When you have a non-standard type in a field, derive `BamlType` on it:

```rust
use dspy_rs::{Signature, BamlType};

#[derive(BamlType, Clone, Debug)]
enum Sentiment {
    Positive,
    Negative,
    Neutral,
}

#[derive(BamlType, Clone, Debug)]
struct Citation {
    /// Document ID
    doc_id: String,
    /// Relevant quote from the document
    quote: String,
}

#[derive(Signature, Clone, Debug)]
/// Analyze sentiment and find supporting citations.
struct Analysis {
    #[input]
    text: String,

    #[output]
    sentiment: Sentiment,

    #[output]
    citations: Vec<Citation>,
}
```

See [Custom Types](/docs/building-blocks/types) for the full `BamlType` reference.

## Demos (few-shot examples)

Attach examples for few-shot prompting via the [predictor](/docs/building-blocks/predictors) builder:

```rust
let predict = Predict::<QA>::builder()
    .demo(QA {
        question: "What is 2+2?".into(),
        answer: "4".into(),
    })
    .demo(QA {
        question: "What color is the sky?".into(),
        answer: "Blue".into(),
    })
    .build();
```

Demos are full signature structs with both input and output fields populated.

## Field attributes

Beyond `#[input]` and `#[output]`, you can use:

### `#[alias]` - Rename for LLM

```rust
#[input]
#[alias = "user_question"]  // LLM sees "user_question", Rust uses "question"
question: String,
```

### `#[format]` - Input serialization

```rust
#[input]
#[format("yaml")]  // serialize this input as YAML in the prompt
context: Vec<Document>,
```

Options: `"json"`, `"yaml"`, `"toon"`

### `#[check]` - Soft constraint

```rust
#[output]
#[check("this >= 0.0 && this <= 1.0", label = "valid_range")]
confidence: f64,
```

Recorded in metadata, doesn't fail parsing. Label is required.

### `#[assert]` - Hard constraint

```rust
#[output]
#[assert("this.len() > 0")]
answer: String,
```

Fails parsing if violated. Label is optional.

See [Constraints](/docs/building-blocks/constraints) for the expression language.

## Where it fits

- A `Signature` doesn't call the LM by itself
- An [`Adapter`](/docs/building-blocks/adapter) turns the signature into a prompt and parses LM responses back into typed outputs
- A [`Predict`](/docs/building-blocks/predictors) orchestrates this: signature + adapter + LM
- Signatures are data - this separation supports reuse, testing, and optimizer integration

```
Signature + Input → Adapter (formats prompt) → LM → Adapter (parses response) → Typed Output
```
