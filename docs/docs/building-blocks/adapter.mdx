---
title: 'Adapter'
description: 'Turn signatures into prompts and parse LM responses'
icon: 'arrows-turn-to-dots'
---

An adapter sits between your [signature](/docs/building-blocks/signature) and the LM. It formats typed inputs into prompts and parses LM responses back into typed outputs.

## What adapters do

```
Signature + Input → Adapter.format() → Prompt for LM
LM Response → Adapter.parse() → Typed Output
```

The default adapter is `ChatAdapter`, which handles both formatting and parsing.

## ChatAdapter

### Prompt structure

The system message has four parts:

1. **Field descriptions** - Lists input/output fields with types and descriptions
2. **Field structure** - Shows the marker format the LM should follow
3. **Response instructions** - Tells the LM the order of output fields
4. **Task description** - Your instruction from the signature docstring

Example system message (simplified):
```
Your input fields are:
1. `question` (string): The question to answer

Your output fields are:
1. `answer` (string): A clear, direct answer

All interactions will be structured in the following way...

[[ ## question ## ]]
question

[[ ## answer ## ]]
Output field `answer` should be of type: string

[[ ## completed ## ]]

Respond with the corresponding output fields, starting with `[[ ## answer ## ]]`,
and then ending with the marker for `[[ ## completed ## ]]`.

In adhering to this structure, your objective is:
        Answer questions accurately and concisely.
```

### Marker protocol

Fields are delimited by markers:

```
[[ ## field_name ## ]]
value here

[[ ## another_field ## ]]
another value

[[ ## completed ## ]]
```

This protocol (inspired by DSPy) allows mixing natural language with structured output.

### Type schemas

For complex types, the adapter renders full schemas using BAML's schema format:

```
[[ ## analysis ## ]]
Output field `analysis` should be of type: Analysis

Definitions (used below):

Sentiment
----
- Positive
- Negative
- Neutral

{
  "sentiment": Sentiment,
  "confidence": float,
  "keywords": string[]
}
```

Type names are simplified for readability:
- Module paths stripped: `my_crate::Sentiment` → `Sentiment`
- `class`/`enum` prefixes removed
- `" | "` → `" or "` (more natural)

### Robust parsing with jsonish

Response parsing uses BAML's `jsonish` parser, which handles:

- **Malformed JSON** - Missing quotes, trailing commas
- **Markdown fences** - Extracts JSON from ```json blocks
- **Type coercion** - `"42"` → `42`, `"true"` → `true`
- **Partial recovery** - Returns what it can parse + all errors

```rust
// Internally:
jsonish::from_str(output_format, &type_ir, &raw_text, true)
```

### Constraint evaluation

After parsing, the adapter runs [constraints](/docs/building-blocks/constraints):

- `#[check]` results → stored in metadata
- `#[assert]` failures → returns `ParseError::AssertFailed`

### Error handling

Parse errors aggregate - you get all problems, not just the first:

```rust
ParseError::Multiple {
    errors: vec![...],  // all field errors
    partial: Some(BamlValue::Map(...)),  // what did parse
}
```

## Using the adapter directly

Usually you don't touch the adapter - `Predict` handles it. But for debugging:

```rust
use dspy_rs::ChatAdapter;

let adapter = ChatAdapter;

// See what prompt would be generated
let system = adapter.format_system_message_typed::<MySignature>()?;
let user = adapter.format_user_message_typed::<MySignature>(&input);

println!("System:\n{system}");
println!("User:\n{user}");
```

This is useful for understanding what the LM sees.

## Input formatting options

The `#[format]` attribute on input fields controls serialization:

```rust
#[derive(Signature, Clone, Debug)]
struct Search {
    #[input]
    query: String,  // plain text

    #[input]
    #[format("yaml")]
    filters: Vec<Filter>,  // serialized as YAML

    #[output]
    results: Vec<Result>,
}
```

Options: `"json"` (default for complex types), `"yaml"`, `"toon"`

## Real example: Insurance claim extraction

Here's what a prompt looks like for a complex nested type (from `examples/16-insurance-claim-prompt.rs`):

```rust
#[derive(Signature, Clone, Debug)]
/// Extract the insurance claim information from the following text.
/// - If you are unsure about a field, leave it as null.
pub struct InsuranceClaimInfo {
    #[input]
    claim_text: String,

    #[output]
    claim: InsuranceClaim,  // complex nested struct with enums
}
```

**Generated system message (condensed):**

```
Your input fields are:
1. `claim_text` (string)

Your output fields are:
1. `claim` (InsuranceClaim)

All interactions will be structured in the following way...

[[ ## claim_text ## ]]
claim_text

[[ ## claim ## ]]
Output field `claim` should be of type: InsuranceClaim

Definitions (used below):

IncidentType
----
- RearEndCollision
- SideImpactCollision
- HeadOnCollision
- ... (more variants)

LocationType
----
- Intersection
- Highway
- ParkingLot
- ... (more variants)

{
  // Basic claim information.
  header: {
    claim_id: string or null,
    report_date: string or null,
    // Channel used to report claim.
    channel: 'Email' or 'Phone' or 'Portal' or 'InPerson' or null,
  },
  // Policy information if available.
  policy_details: {
    policy_number: string or null,
    coverage_type: 'Property' or 'Auto' or 'Liability' or ... or null,
  } or null,
  // List of insured objects involved.
  insured_objects: [
    {
      object_type: 'Vehicle' or 'Building' or 'Person' or 'Other',
      year: int or null,
      estimated_value: int or null,
    }
  ] or null,
  incident_description: {
    incident_type: IncidentType,
    location_type: LocationType,
  } or null,
}

[[ ## completed ## ]]

Respond with the corresponding output fields, starting with `[[ ## claim ## ]]`,
and then ending with the marker for `[[ ## completed ## ]]`.

In adhering to this structure, your objective is:
        Extract the insurance claim information from the following text.
        - If you are unsure about a field, leave it as null.
```

**Generated user message:**

```
[[ ## claim_text ## ]]
A raccoon bumped a parked scooter in a driveway. Reported by Taylor P. via phone.
```

Notice how:
- Enums with many variants become "Definitions" at the top
- Doc comments become inline `//` comments in the schema
- `Option<T>` renders as `T or null`
- Nested objects show their full structure
- The instruction comes from the signature docstring

## Design notes

- **DSPy inspiration:** Marker protocol from DSPy's ChatAdapter
- **BAML inspiration:** Schema rendering and jsonish parsing from BAML
- **Separation of concerns:** Adapter doesn't know about LMs - just formatting/parsing
