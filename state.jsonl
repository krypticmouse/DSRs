{"id":"dsrs-ohh","created_at":[1767986111614,1],"created_by":"darin@darinsmacstudio.lan","title":"BAML-Bridge Typed DSPy-RS Integration","description":"# Strategic Goal\n\nTransform DSPy-RS from untyped HashMap-based API to fully typed Rust structs, leveraging BAML-Bridge for schema generation and parsing. This is a **foundational infrastructure change** that enables:\n\n1. **Developer Experience**: Compile-time field validation, IDE autocomplete, direct field access\n2. **Reliability**: Sophisticated LLM output parsing via jsonish (handles quirks, partial outputs)\n3. **Observability**: Rich metadata per field (raw text, parsing flags, constraint results)\n4. **Correctness**: Constraint system (check=soft warning, assert=hard error)\n\n## Current State (Legacy)\n\n```\nUser code → Example (HashMap<String, Value>) → MetaSignature → ChatAdapter → LLM\nLLM → ChatAdapter.parse_response → Prediction (HashMap<String, Value>) → User code\n```\n\n**Problems:**\n- Runtime field access: `result.get(\"answer\").unwrap().as_str().unwrap()`\n- No compile-time validation of field names/types\n- Coarse error handling (anyhow::Result)\n- Basic JSON parsing (doesn't handle LLM quirks)\n- No constraint validation\n\n## Target State (Typed)\n\n```\nUser code → QAInput (typed) → Signature trait → ChatAdapter.format_typed → LLM\nLLM → ChatAdapter.parse_typed → jsonish → BamlValue → QA (typed) → User code\n```\n\n**Benefits:**\n- Direct field access: `result.answer`\n- Compile-time field validation\n- Structured errors with partial results\n- jsonish parser handles LLM output quirks\n- check/assert constraint validation\n\n## Key Design Decisions\n\n1. **Three Generated Structs**: QAInput (public), __QAOutput (hidden), __QAAll (hidden for delegation)\n2. **Function Pointers for TypeIR**: `fn() -> TypeIR` because TypeIR isn't const-constructible\n3. **ParseError::Multiple**: Collect ALL field failures, not just first\n4. **Marker Protocol**: Keep `[[ ## field ## ]]` markers, add BAML schema in system message\n\n## Reference Files\n- CURRENT_PLAN.md - Detailed implementation walkthrough\n- CURRENT_SPEC.md - API specification and acceptance criteria\n- crates/dspy-rs/src/core/signature.rs - Legacy MetaSignature trait\n- baml-bridge/crates/bridge/src/lib.rs - BamlType, parse_llm_output, Parsed<T>","acceptance_criteria":"1. #[derive(Signature)] generates QAInput, __QAOutput, impl Signature for user struct\n2. Predict<S>::call(input) returns Result<S, PredictError> with typed output\n3. CallResult<S> provides field_flags(), field_checks(), field_raw() accessors\n4. PredictError hierarchy: Lm/Parse/Conversion with structured context\n5. ParseError::Multiple preserves partial results\n6. All existing tests pass (backward compatibility via feature flag or parallel API)\n7. New typed API has integration test with real LLM call","priority":0,"type":"epic","labels":[],"status":"open","_at":[1767986111614,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.1","created_at":[1767986126009,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 0: Foundation - Dependencies and Re-exports","description":"# Purpose\n\nEstablish the bridge between dspy-rs and baml-bridge crates. This is foundational scaffolding that enables all subsequent work.\n\n## Why This Matters\n\nThe derive(Signature) macro will generate code that references types like `TypeIR`, `Constraint`, `OutputFormatContent`. These must be accessible via `dspy_rs::` paths so:\n1. User code doesn't need to depend on baml-bridge directly\n2. Macro-generated code has stable import paths\n3. Version coupling is managed in one place (dspy-rs Cargo.toml)\n\n## Technical Context\n\nbaml-bridge exposes:\n- `BamlType` derive macro + trait\n- `baml_types::{TypeIR, BamlValue, Constraint, ...}`\n- `internal_baml_jinja::types::{OutputFormatContent, RenderOptions}`\n- `jsonish::deserializer::...` for parsing\n\n## Risk Assessment\n- LOW: This is configuration, not complex logic\n- Compile-time validation: cargo check will catch missing re-exports\n\n## Search Context (for future self)\n- `baml-bridge/crates/bridge/src/lib.rs:1-30` - public exports\n- `crates/dspy-rs/Cargo.toml` - dependency section\n- `crates/dspy-rs/src/lib.rs` - existing re-export pattern","acceptance_criteria":"1. baml-bridge dependency added to Cargo.toml\n2. Re-exports in lib.rs compile successfully\n3. cargo check passes for dspy-rs crate","priority":1,"type":"epic","labels":[],"status":"open","_at":[1767986126009,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.1.1","created_at":[1767986135863,1],"created_by":"darin@darinsmacstudio.lan","title":"Add baml-bridge path dependency to Cargo.toml","description":"# Task\n\nAdd baml-bridge as a path dependency to dspy-rs.\n\n## File to Modify\n`crates/dspy-rs/Cargo.toml`\n\n## Change\nAdd to [dependencies]:\n```toml\nbaml-bridge = { path = \"../../baml-bridge/crates/bridge\", features = [\"derive\"] }\n```\n\n## Why 'derive' Feature\nThe derive feature enables `#[derive(BamlType)]` which we need for generated structs.\n\n## Search Context\n- Use morph: `[dependencies]` in crates/dspy-rs/Cargo.toml\n- Use morph: `features` in baml-bridge/crates/bridge/Cargo.toml\n\n## Verification\n```bash\ncd crates/dspy-rs && cargo check\n```\n\n## Gotcha\nPath is relative from crates/dspy-rs, so `../../baml-bridge/crates/bridge` goes up to repo root then into baml-bridge.","acceptance_criteria":"cargo check passes with baml-bridge dependency","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986135863,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.1.2","created_at":[1767986149629,1],"created_by":"darin@darinsmacstudio.lan","title":"Add BAML type re-exports to lib.rs","description":"# Task\n\nRe-export BAML types from dspy-rs so macro-generated code can use `dspy_rs::` paths.\n\n## File to Modify\n`crates/dspy-rs/src/lib.rs`\n\n## Changes\n\nAdd near existing re-exports:\n```rust\n// BAML-Bridge re-exports for typed API\npub use baml_bridge;  // Full crate access for power users\npub use baml_bridge::BamlType;  // Derive macro\n\n// Core types for schema/parsing\npub use baml_bridge::baml_types::{\n    BamlValue, Constraint, ConstraintLevel, ResponseCheck, \n    TypeIR, StreamingMode, TypeValue,\n};\n\n// Schema rendering\npub use baml_bridge::internal_baml_jinja::types::{\n    OutputFormatContent, RenderOptions,\n};\n\n// Parsing metadata\npub use baml_bridge::jsonish::deserializer::deserialize_flags::Flag;\n\n// Conversion error for error hierarchy\npub use baml_bridge::BamlConvertError;\n```\n\n## Why Each Type\n\n| Type | Used By | Purpose |\n|------|---------|---------|\n| BamlType | derive(Signature) | Generates impl for QAInput, __QAOutput |\n| TypeIR | FieldSpec | Type schema for parsing |\n| Constraint | derive(Signature) | check/assert constraint definitions |\n| OutputFormatContent | Signature trait | Schema rendering for prompts |\n| Flag | CallResult | Parsing metadata (coercion flags) |\n| BamlConvertError | ConversionError | Error wrapping |\n\n## Search Context\n- Use morph: `pub use` in crates/dspy-rs/src/lib.rs for existing pattern\n- Use morph: `pub use` in baml-bridge/crates/bridge/src/lib.rs for available exports\n\n## Verification\n```rust\n// In a test or example:\nuse dspy_rs::{BamlType, TypeIR, OutputFormatContent};\n```","acceptance_criteria":"All listed types importable via dspy_rs:: path","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986149629,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2","created_at":[1767986175327,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 1: Core API Types - Signature Trait and Error Hierarchy","description":"# Purpose\n\nDefine the typed API contract: the Signature trait, field metadata types, error hierarchy, and CallResult. This phase is pure type definitions - no implementation logic.\n\n## Why This Structure\n\nThe typed API needs several cooperating types:\n\n### Signature Trait\nReplaces `MetaSignature`. Key differences:\n- Associated types `Input` and `Output` (vs dynamic dispatch)\n- Static field metadata (vs runtime Value)\n- `from_parts`/`into_parts` for struct assembly/disassembly\n\n### Error Hierarchy\nCurrent: `anyhow::Result<Prediction>` - no structure, hard to handle programmatically\n\nTarget:\n```\nPredictError\n├── Lm { source: LmError }      // LLM call failed\n├── Parse { source: ParseError, raw_response, usage }\n└── Conversion { source: ConversionError, parsed }\n```\n\nParseError:\n```\n├── MissingField { field, raw }         // Marker not found\n├── ExtractionFailed { field, raw, reason }  // Between markers empty/invalid\n├── CoercionFailed { field, expected, raw, source }  // jsonish couldn't parse\n├── AssertFailed { field, label, expr, value }  // Hard constraint failed\n└── Multiple { errors, partial }        // Multiple fields failed\n```\n\n### CallResult<O>\nWraps successful output with metadata:\n- Per-field raw text\n- Parsing flags (what coercions were applied)\n- Constraint results (check passed/failed)\n\n## Design Rationale\n\n1. **Separate ParseError from ConversionError**: Parse = extracting from LLM text, Conversion = BamlValue → typed struct\n2. **Multiple variant**: Don't fail fast - collect ALL errors for better debugging\n3. **Partial results**: Even on error, preserve what DID parse successfully\n4. **FieldMeta per field**: Enables debugging 'why did this field parse this way?'\n\n## Search Context\n- Use morph: `thiserror` in Cargo.toml (check if available)\n- Use morph: `MetaSignature` in crates/dspy-rs for legacy trait\n- Use morph: `BamlConvertError` in baml-bridge for conversion error structure\n- Use morph: `ResponseCheck` in baml-types for constraint result structure","acceptance_criteria":"1. FieldSpec, ConstraintSpec, ConstraintKind types defined and exported\n2. Signature trait defined with Input/Output associated types\n3. PredictError, ParseError, ConversionError, LmError defined with thiserror\n4. CallResult<O> with field_flags(), field_checks(), field_raw() accessors\n5. All types exported from core/mod.rs and lib.rs\n6. Unit tests for error construction and CallResult accessors","priority":1,"type":"epic","labels":[],"status":"open","_at":[1767986175327,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2.1","created_at":[1767986193259,1],"created_by":"darin@darinsmacstudio.lan","title":"Define FieldSpec, ConstraintSpec, and ConstraintKind types","description":"# Task\n\nCreate metadata types that describe signature fields at compile time.\n\n## File to Create/Modify\n`crates/dspy-rs/src/core/signature.rs` (alongside or replacing MetaSignature)\n\n## Types to Define\n\n```rust\n/// Describes a single field in a signature (input or output)\npub struct FieldSpec {\n    /// LLM-facing name (may be aliased via #[alias(\"name\")])\n    pub name: &'static str,\n    \n    /// Rust struct field identifier\n    pub rust_name: &'static str,\n    \n    /// Doc comment from field (used in prompts)\n    pub description: &'static str,\n    \n    /// Function returning TypeIR for this field\n    /// Why fn pointer: TypeIR isn't const-constructible\n    pub type_ir: fn() -> TypeIR,\n    \n    /// Constraints defined on this field\n    pub constraints: &'static [ConstraintSpec],\n}\n\n/// A constraint defined via #[check] or #[assert] attribute\npub struct ConstraintSpec {\n    pub kind: ConstraintKind,\n    \n    /// User-provided label (required for check, optional for assert)\n    pub label: &'static str,\n    \n    /// The constraint expression (e.g., \"this >= 0.0 && this <= 1.0\")\n    pub expression: &'static str,\n}\n\n/// Distinguishes soft (check) from hard (assert) constraints\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ConstraintKind {\n    /// Soft constraint - failure recorded in metadata but not an error\n    Check,\n    /// Hard constraint - failure causes ParseError::AssertFailed\n    Assert,\n}\n```\n\n## Why Static Lifetimes?\n\nAll data is compile-time constant:\n- `name`, `rust_name`, `description`, `label`, `expression`: string literals from macro\n- `constraints`: static array slice\n- `type_ir`: function pointer\n\nThis enables zero-allocation field introspection.\n\n## Why fn() -> TypeIR?\n\nTypeIR construction may involve heap allocation (String fields). Rust doesn't allow this in const contexts. A function pointer defers construction to first use.\n\n## Search Context\n- Use morph: `TypeIR` in baml-types for the type we're wrapping\n- Use morph: `Constraint` in baml-types for existing constraint type","acceptance_criteria":"1. All three types compile and are public\n2. FieldSpec can be constructed in const/static context (except type_ir call)\n3. Types derive Debug, Clone where appropriate","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986193259,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2.2","created_at":[1767986213651,1],"created_by":"darin@darinsmacstudio.lan","title":"Define typed Signature trait","description":"# Task\n\nDefine the core Signature trait that replaces MetaSignature for typed API.\n\n## File\n`crates/dspy-rs/src/core/signature.rs`\n\n## Trait Definition\n\n```rust\n/// Typed signature trait - implemented by #[derive(Signature)] macro.\n/// \n/// Unlike MetaSignature which uses runtime Value, this provides compile-time\n/// type safety through associated types.\npub trait Signature: Send + Sync + 'static {\n    /// Input struct type (e.g., QAInput)\n    /// Must implement BamlType for schema generation\n    type Input: baml_bridge::BamlType + Send + Sync;\n    \n    /// Output-only struct type (e.g., __QAOutput)\n    /// Hidden from users, used for parsing\n    type Output: baml_bridge::BamlType + Send + Sync;\n    \n    /// Instruction extracted from doc comment\n    fn instruction() -> &'static str;\n    \n    /// Input field metadata for prompt formatting\n    fn input_fields() -> &'static [FieldSpec];\n    \n    /// Output field metadata for parsing and schema\n    fn output_fields() -> &'static [FieldSpec];\n    \n    /// Pre-computed output schema for LLM prompts\n    /// Static lifetime because computed once at startup\n    fn output_format_content() -> &'static OutputFormatContent;\n    \n    /// Construct full signature struct from input + parsed output\n    /// Called after successful parsing\n    fn from_parts(input: Self::Input, output: Self::Output) -> Self;\n    \n    /// Decompose into input and output parts\n    /// Used for demo formatting\n    fn into_parts(self) -> (Self::Input, Self::Output);\n}\n```\n\n## Design Notes\n\n### Why Associated Types?\n- Enables `Predict<S: Signature>` - generic over signature\n- Compile-time type checking of inputs/outputs\n- No trait object indirection for hot path\n\n### Why from_parts/into_parts?\n- `from_parts`: After parsing `__QAOutput`, construct the full `QA` struct\n- `into_parts`: For demos, split `QA` into input fields (for user message) and output fields (for assistant message)\n\n### Why output_format_content() -> &'static?\n- Schema is computed once per type (OnceLock in generated code)\n- Avoid recomputing on every call\n- Safe because OutputFormatContent is immutable\n\n## Relationship to MetaSignature\n\nMetaSignature (legacy):\n- `fn demos(&self)` - runtime demo storage\n- `fn input_fields(&self) -> Value` - JSON schema blob\n- `fn update_instruction(&mut self)` - mutable\n\nSignature (new):\n- No demo storage (Predict<S> holds demos)\n- Static field metadata (FieldSpec arrays)\n- Immutable (all methods are associated functions)\n\n## Search Context\n- Use morph: `trait MetaSignature` in signature.rs for legacy comparison\n- Use morph: `BamlType` trait bounds in baml-bridge","acceptance_criteria":"1. Trait compiles with all methods\n2. Associated type bounds compile (BamlType + Send + Sync)\n3. Can be used as bound: fn foo<S: Signature>()","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986213651,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2.3","created_at":[1767986238439,1],"created_by":"darin@darinsmacstudio.lan","title":"Define PredictError, ParseError, ConversionError, LmError hierarchy","description":"# Task\n\nCreate structured error types for the typed API. These replace the current `anyhow::Result` with actionable, pattern-matchable errors.\n\n## File to Create\n`crates/dspy-rs/src/core/errors.rs`\n\n## Error Hierarchy\n\n```rust\nuse crate::{BamlValue, LmUsage, Flag};\nuse thiserror::Error;\n\n/// Top-level error from Predict<S>::call()\n#[derive(Debug, Error)]\npub enum PredictError {\n    #[error(\"LLM call failed\")]\n    Lm {\n        #[source]\n        source: LmError,\n    },\n    \n    #[error(\"failed to parse LLM response\")]\n    Parse {\n        #[source]\n        source: ParseError,\n        /// Raw LLM output for debugging\n        raw_response: String,\n        /// Token usage even on failure\n        lm_usage: LmUsage,\n    },\n    \n    #[error(\"failed to convert parsed value to output type\")]\n    Conversion {\n        #[source]\n        source: ConversionError,\n        /// Successfully parsed BamlValue\n        parsed: BamlValue,\n    },\n}\n\n/// Errors during LLM output parsing (marker extraction + jsonish)\n#[derive(Debug, Error)]\npub enum ParseError {\n    #[error(\"missing field '{field}' in response\")]\n    MissingField {\n        field: String,\n        raw_response: String,\n    },\n    \n    #[error(\"failed to extract field '{field}'\")]\n    ExtractionFailed {\n        field: String,\n        raw_response: String,\n        reason: String,\n    },\n    \n    #[error(\"coercion failed for field '{field}': expected {expected_type}\")]\n    CoercionFailed {\n        field: String,\n        expected_type: String,\n        raw_text: String,\n        #[source]\n        source: JsonishError,\n    },\n    \n    #[error(\"assert constraint '{label}' failed for field '{field}'\")]\n    AssertFailed {\n        field: String,\n        label: String,\n        expression: String,\n        value: BamlValue,\n    },\n    \n    #[error(\"multiple parse errors\")]\n    Multiple {\n        errors: Vec<ParseError>,\n        /// Partial result: successfully parsed fields\n        partial: Option<BamlValue>,\n    },\n}\n\n/// Wrapper for jsonish errors (prevents anyhow leak)\n#[derive(Debug, Error)]\n#[error(\"jsonish parse error: {message}\")]\npub struct JsonishError {\n    pub message: String,\n    // Could add more context later\n}\n\nimpl From<anyhow::Error> for JsonishError {\n    fn from(e: anyhow::Error) -> Self {\n        Self { message: e.to_string() }\n    }\n}\n\n/// Errors converting BamlValue to typed struct\n#[derive(Debug, Error)]\n#[error(\"{message} (expected {expected}, got {got}) at {}\", path_string())]\npub struct ConversionError {\n    pub path: Vec<String>,\n    pub expected: &'static str,\n    pub got: String,\n    pub message: String,\n}\n\nimpl ConversionError {\n    pub fn path_string(&self) -> String {\n        if self.path.is_empty() {\n            \"<root>\".to_string()\n        } else {\n            self.path.join(\".\")\n        }\n    }\n}\n\nimpl From<crate::BamlConvertError> for ConversionError {\n    fn from(e: crate::BamlConvertError) -> Self {\n        Self {\n            path: e.path,\n            expected: e.expected,\n            got: e.got,\n            message: e.message,\n        }\n    }\n}\n\n/// LLM provider errors (coarse for now, refine later)\n#[derive(Debug, Error)]\npub enum LmError {\n    #[error(\"provider error: {message}\")]\n    Provider { message: String },\n    \n    #[error(\"rate limited\")]\n    RateLimited,\n    \n    #[error(\"timeout after {duration_ms}ms\")]\n    Timeout { duration_ms: u64 },\n    \n    #[error(\"invalid response\")]\n    InvalidResponse { details: String },\n}\n```\n\n## Design Rationale\n\n### Why wrap jsonish errors?\njsonish returns `anyhow::Error`. We don't want to leak `anyhow` in our public API. `JsonishError` wraps it with stable structure.\n\n### Why Multiple variant?\nWhen parsing multiple output fields, we want ALL errors, not just the first. This enables:\n- Better debugging (see all failures at once)\n- Partial results (fields that DID parse successfully)\n\n### Why ConversionError separate from ParseError?\n- ParseError = \"couldn't understand LLM output\"\n- ConversionError = \"understood it but wrong type\"\n\nExample: LLM returns `{\"count\": \"five\"}` for `count: i32`\n- ParseError::CoercionFailed if jsonish can't coerce\n- ConversionError if jsonish produces BamlValue::String but we need i32\n\n## Search Context\n- Use morph: `BamlConvertError` in baml-bridge for source structure\n- Use morph: `anyhow::Error` in jsonish for what we're wrapping\n- Use morph: `LmUsage` in dspy-rs for usage type","acceptance_criteria":"1. All error types compile with thiserror\n2. From<BamlConvertError> for ConversionError works\n3. From<anyhow::Error> for JsonishError works\n4. PredictError variants contain all required context fields","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986238439,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2.4","created_at":[1767986262401,1],"created_by":"darin@darinsmacstudio.lan","title":"Define CallResult<O> with per-field metadata","description":"# Task\n\nCreate CallResult<O> that wraps successful prediction output with rich metadata.\n\n## File to Create\n`crates/dspy-rs/src/core/call_result.rs`\n\n## Type Definition\n\n```rust\nuse indexmap::IndexMap;\nuse rig::message::ToolCall;\nuse crate::{Flag, LmUsage};\n\n/// Result of a successful Predict<S>::call_with_meta()\n/// \n/// Contains the typed output plus per-field metadata for debugging\n/// and introspection.\npub struct CallResult<O> {\n    /// The typed output struct\n    pub output: O,\n    \n    /// Raw LLM response text\n    pub raw_response: String,\n    \n    /// Token usage statistics\n    pub lm_usage: LmUsage,\n    \n    /// Tool calls made during generation (if any)\n    pub tool_calls: Vec<ToolCall>,\n    \n    /// Results of tool executions (if any)\n    pub tool_executions: Vec<String>,\n    \n    /// Node ID in trace DAG (if tracing enabled)\n    pub node_id: Option<usize>,\n    \n    /// Per-field parsing metadata, keyed by Rust field name\n    fields: IndexMap<String, FieldMeta>,\n}\n\n/// Metadata about how a single field was parsed\n#[derive(Debug, Clone)]\npub struct FieldMeta {\n    /// Raw text extracted between markers\n    pub raw_text: String,\n    \n    /// Parsing flags from jsonish (what coercions applied)\n    pub flags: Vec<Flag>,\n    \n    /// Results of check/assert constraints\n    pub checks: Vec<ConstraintResult>,\n}\n\n/// Result of evaluating a constraint\n#[derive(Debug, Clone)]\npub struct ConstraintResult {\n    /// Constraint label (from #[check(label=\"...\")])\n    pub label: String,\n    \n    /// The constraint expression\n    pub expression: String,\n    \n    /// Whether constraint passed\n    pub passed: bool,\n}\n\nimpl<O> CallResult<O> {\n    /// Get parsing flags for a field (e.g., \"was this coerced from string?\")\n    pub fn field_flags(&self, field: &str) -> &[Flag] {\n        self.fields.get(field)\n            .map(|m| m.flags.as_slice())\n            .unwrap_or(&[])\n    }\n    \n    /// Get constraint results for a field\n    pub fn field_checks(&self, field: &str) -> &[ConstraintResult] {\n        self.fields.get(field)\n            .map(|m| m.checks.as_slice())\n            .unwrap_or(&[])\n    }\n    \n    /// Get raw text that was parsed for a field\n    pub fn field_raw(&self, field: &str) -> Option<&str> {\n        self.fields.get(field).map(|m| m.raw_text.as_str())\n    }\n    \n    /// Get all field names that have metadata\n    pub fn field_names(&self) -> impl Iterator<Item = &str> {\n        self.fields.keys().map(|s| s.as_str())\n    }\n    \n    /// Check if any constraints failed (but weren't asserts)\n    pub fn has_failed_checks(&self) -> bool {\n        self.fields.values()\n            .flat_map(|m| &m.checks)\n            .any(|c| \\!c.passed)\n    }\n}\n```\n\n## Usage Example\n\n```rust\nlet result = predict.call_with_meta(input).await?;\n\n// Access typed output\nprintln\\!(\"Answer: {}\", result.output.answer);\n\n// Debug: what was the raw text for 'confidence'?\nif let Some(raw) = result.field_raw(\"confidence\") {\n    println\\!(\"Raw confidence text: {}\", raw);\n}\n\n// Check: did any soft constraints fail?\nfor check in result.field_checks(\"confidence\") {\n    if \\!check.passed {\n        eprintln\\!(\"Warning: check '{}' failed\", check.label);\n    }\n}\n\n// Debug: was coercion applied?\nfor flag in result.field_flags(\"count\") {\n    println\\!(\"Parsing flag: {:?}\", flag);\n}\n```\n\n## Why IndexMap?\n\nPreserves insertion order (output field order), which is useful for debugging and consistent iteration.\n\n## Naming Collision\n\nThere's an existing `CallResult` in `utils/cache.rs`. Phase 6 will rename that to `CacheEntry`. Until then, use full path or feature-gate.\n\n## Search Context\n- Use morph: `Flag` in jsonish deserialize_flags for flag type\n- Use morph: `ResponseCheck` in baml-types for constraint result inspiration\n- Use morph: `ToolCall` in rig::message for tool call type\n- Use morph: `CallResult` in utils/cache.rs to understand collision","acceptance_criteria":"1. CallResult<O> compiles with all fields\n2. Accessor methods return correct slices/options\n3. has_failed_checks() correctly identifies failed constraints\n4. Unit test for CallResult construction and accessors","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986262401,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.2.5","created_at":[1767986275995,1],"created_by":"darin@darinsmacstudio.lan","title":"Wire up core module exports for new types","description":"# Task\n\nExport all new types from core/mod.rs and lib.rs.\n\n## Files to Modify\n\n### crates/dspy-rs/src/core/mod.rs\n```rust\n// Add modules\nmod call_result;\nmod errors;\n// signature.rs already exists\n\n// Add exports\npub use call_result::{CallResult, FieldMeta, ConstraintResult};\npub use errors::{PredictError, ParseError, ConversionError, LmError, JsonishError};\npub use signature::{Signature, FieldSpec, ConstraintSpec, ConstraintKind};\n// Keep MetaSignature export for backward compatibility\n```\n\n### crates/dspy-rs/src/lib.rs\n```rust\n// Add to existing pub use core::...\npub use core::{\n    // Existing\n    MetaSignature, Module, Optimizable,\n    // New typed API\n    Signature, FieldSpec, ConstraintSpec, ConstraintKind,\n    CallResult, FieldMeta, ConstraintResult,\n    PredictError, ParseError, ConversionError, LmError,\n};\n```\n\n## Verification\n\n```rust\n// Should all work:\nuse dspy_rs::{Signature, PredictError, CallResult};\nuse dspy_rs::core::{FieldSpec, ConstraintKind};\n```\n\n## Search Context\n- Use morph: `pub use` in crates/dspy-rs/src/core/mod.rs for existing pattern\n- Use morph: `pub use core::` in crates/dspy-rs/src/lib.rs","acceptance_criteria":"All new types importable via dspy_rs:: path","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986275995,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr","created_at":[1767984841920,0],"created_by":"darin@darinsmacstudio.lan","title":"BAML-Bridge Integration: Typed DSPy-RS API","description":"Migrate dspy-rs from untyped HashMap<String, serde_json::Value> to typed Signature structs using baml-bridge for schema rendering and jsonish parsing. Transforms user-facing API from Example/Prediction to typed QAInput/QA structs. See CURRENT_PLAN.md and CURRENT_SPEC.md for full details.","acceptance_criteria":"1. #[derive(Signature)] generates QAInput, __QAOutput, impl Signature\n2. ChatAdapter uses BAML OutputFormatContent for schema rendering\n3. Parsing uses jsonish with per-field extraction and constraint evaluation\n4. Predict<S> returns CallResult<S> with field metadata\n5. PredictError hierarchy matches spec (Lm/Parse/Conversion variants)","priority":1,"type":"epic","labels":[],"status":"closed","closed_at":[1767986091322,1],"closed_by":"darin@darinsmacstudio.lan","closed_reason":"Restructuring: replacing with more granular epic","_at":[1767986091322,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1767984841920,0],"darin@darinsmacstudio.lan"],"claim":[[1767984841920,0],"darin@darinsmacstudio.lan"],"description":[[1767984841920,0],"darin@darinsmacstudio.lan"],"design":[[1767984841920,0],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1767984841920,0],"darin@darinsmacstudio.lan"],"external_ref":[[1767984841920,0],"darin@darinsmacstudio.lan"],"labels":[[1767984841920,0],"darin@darinsmacstudio.lan"],"priority":[[1767984841920,0],"darin@darinsmacstudio.lan"],"source_repo":[[1767984841920,0],"darin@darinsmacstudio.lan"],"title":[[1767984841920,0],"darin@darinsmacstudio.lan"],"type":[[1767984841920,0],"darin@darinsmacstudio.lan"]}}
{"id":"dsrs-vyr.1","created_at":[1767984854449,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 0: Add baml-bridge dependency and re-exports","description":"Add baml-bridge path dependency to dspy-rs and set up re-exports for macro-generated code.\n\n**Files to modify:**\n- crates/dspy-rs/Cargo.toml - add baml-bridge dependency\n- crates/dspy-rs/src/lib.rs - add re-exports\n\n**Search context (use morph):**\n- Search 'baml-bridge/crates/bridge' for available public types\n- Search 'pub use' in dspy-rs/src/lib.rs for existing re-export pattern\n- Search 'BamlValue' and 'TypeIR' in baml-bridge for types to re-export\n\n**Re-exports needed:**\n```rust\npub use baml_bridge::BamlType;\npub use baml_bridge::baml_types::{BamlValue, Constraint, ConstraintLevel, ResponseCheck, TypeIR, StreamingMode, TypeValue};\npub use baml_bridge::internal_baml_jinja::types::{OutputFormatContent, RenderOptions};\npub use baml_bridge::jsonish::deserializer::deserialize_flags::Flag;\n```\n\n**Dependency path:** `baml-bridge = { path = \"../../baml-bridge/crates/bridge\", features = [\"derive\"] }`","acceptance_criteria":"1. Cargo.toml has baml-bridge dependency\n2. lib.rs re-exports BamlType, TypeIR, Constraint, OutputFormatContent, Flag\n3. cargo check passes in dspy-rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984854449,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.2","created_at":[1767984869507,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 1: Define typed Signature trait and core types","description":"Create the new typed Signature trait, FieldSpec, ConstraintSpec, and error types that replace the legacy MetaSignature.\n\n**Files to create/modify:**\n- crates/dspy-rs/src/core/signature.rs - new typed Signature trait + FieldSpec/ConstraintSpec\n- crates/dspy-rs/src/core/errors.rs (NEW) - PredictError, ParseError, ConversionError hierarchy\n- crates/dspy-rs/src/core/call_result.rs (NEW) - CallResult<O> with FieldMeta\n- crates/dspy-rs/src/core/mod.rs - re-export new modules\n\n**Search context (use morph):**\n- Search 'MetaSignature' in dspy-rs to understand legacy trait\n- Search 'FieldMeta' or 'field metadata' in baml-bridge for inspiration\n- Search 'thiserror' in Cargo.toml to check if available\n- Search 'ResponseCheck' in baml-types for constraint result patterns\n\n**New types to define:**\n```rust\npub struct FieldSpec {\n    pub name: &'static str,       // LLM-facing name (alias or original)\n    pub rust_name: &'static str,  // Rust field ident\n    pub description: &'static str,\n    pub type_ir: fn() -> TypeIR,\n    pub constraints: &'static [ConstraintSpec],\n}\n\npub trait Signature: Send + Sync + 'static {\n    type Input: baml_bridge::BamlType;\n    type Output: baml_bridge::BamlType;\n    fn instruction() -> &'static str;\n    fn input_fields() -> &'static [FieldSpec];\n    fn output_fields() -> &'static [FieldSpec];\n    fn output_format_content() -> &'static OutputFormatContent;\n    fn from_parts(input: Self::Input, output: Self::Output) -> Self;\n    fn into_parts(self) -> (Self::Input, Self::Output);\n}\n```","acceptance_criteria":"1. FieldSpec, ConstraintSpec, ConstraintKind types defined\n2. Typed Signature trait with Input/Output associated types\n3. PredictError with Lm/Parse/Conversion variants\n4. ParseError with MissingField/ExtractionFailed/CoercionFailed/AssertFailed/Multiple variants\n5. CallResult<O> with field_flags(), field_checks(), field_raw() accessors\n6. All types exported from core/mod.rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984869507,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.3","created_at":[1767984884339,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 2: Add ToBamlValue trait in baml-bridge","description":"Add the missing ToBamlValue trait to convert typed Rust values to BamlValue for prompt rendering. This enables typed demos and inputs without serde_json::Value.\n\n**Files to modify:**\n- baml-bridge/crates/bridge/src/lib.rs - add ToBamlValue trait + impls\n- baml-bridge/crates/baml-bridge-derive/src/lib.rs - extend derive(BamlType) to impl ToBamlValue\n\n**Search context (use morph):**\n- Search 'BamlValueConvert' in bridge for existing from-value conversion pattern\n- Search 'BamlValue::Class' or 'BamlValue::Enum' for value construction\n- Search 'derive(BamlType)' in baml-bridge-derive for macro expansion pattern\n- Search 'to_baml' or 'into_baml' for any existing conversion\n\n**New trait:**\n```rust\npub trait ToBamlValue {\n    fn to_baml_value(&self) -> baml_types::BamlValue;\n}\n```\n\n**Implement for:**\n- Primitives: String, &str, bool, i32, i64, f32, f64, etc.\n- Containers: Option<T>, Vec<T>, HashMap<String, T>, BTreeMap<String, T>\n- derive(BamlType) structs: convert each field, return BamlValue::Class(name, map)\n- derive(BamlType) enums: return BamlValue::Enum(enum_name, variant_string)\n\n**Critical:** Mirror the exact representation that BamlValueConvert expects when parsing. Check how parsing returns enums/classes and produce the inverse.","acceptance_criteria":"1. ToBamlValue trait defined and exported from bridge\n2. Primitive types implement ToBamlValue (String, bool, numerics)\n3. Option<T>, Vec<T>, HashMap<String,T> implement ToBamlValue\n4. derive(BamlType) generates ToBamlValue impl for structs\n5. derive(BamlType) generates ToBamlValue impl for enums\n6. Round-trip test: to_baml_value() -> try_from_baml_value() == original","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984884339,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.4","created_at":[1767984901199,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 3: Implement derive(Signature) macro","description":"Replace the existing #[Signature] attribute macro with #[derive(Signature)] that generates typed input/output structs and Signature trait impl.\n\n**Files to modify:**\n- crates/dsrs-macros/src/lib.rs - add proc_macro_derive(Signature), rename/gate old attribute macro\n- crates/dsrs-macros/Cargo.toml - ensure syn/quote dependencies support derives\n\n**Search context (use morph):**\n- Search 'proc_macro_attribute' in dsrs-macros for existing Signature macro\n- Search 'proc_macro_derive' for derive macro pattern examples\n- Search 'BamlType' derive in baml-bridge-derive for struct/field parsing\n- Search 'syn::DeriveInput' for derive input parsing pattern\n\n**Given user code:**\n```rust\n#[derive(Signature)]\n/// Answer questions accurately\npub struct QA {\n    #[input] pub question: String,\n    #[input] pub context: Option<String>,\n    #[output] pub answer: String,\n    #[output] #[check(\"this >= 0.0\", label = \"range\")] pub confidence: f32,\n}\n```\n\n**Must generate:**\n1. `QAInput` - public struct with only #[input] fields, derives BamlType\n2. `__QAOutput` - hidden struct with only #[output] fields, derives BamlType\n3. `__QAAll` - hidden struct with all fields for delegation\n4. BamlType/BamlValueConvert/ToBamlValue impls for QA via delegation to __QAAll\n5. `impl Signature for QA` with Input/Output types, instruction from doc comment\n6. Static `__QA_INPUT_FIELDS` and `__QA_OUTPUT_FIELDS` slices of FieldSpec\n7. fn pointers for type_ir construction with constraints\n\n**Validation rules:**\n- Struct only, named fields only\n- Each field must have exactly one of #[input] or #[output]\n- Must have >= 1 input and >= 1 output\n- #[check(...)] must include label = \"...\"","acceptance_criteria":"1. derive(Signature) compiles and generates QAInput, __QAOutput\n2. Generated QAInput derives BamlType\n3. impl Signature for QA with correct associated types\n4. input_fields() and output_fields() return static FieldSpec slices\n5. from_parts/into_parts work correctly\n6. Compile errors for: missing input, missing output, no label on check","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984901199,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.5","created_at":[1767984917767,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 4: Typed prompting and parsing in ChatAdapter","description":"Add typed formatting and parsing functions to ChatAdapter that use BAML schema rendering and jsonish parsing.\n\n**Files to modify:**\n- crates/dspy-rs/src/adapter/chat.rs - add typed format/parse functions\n\n**Search context (use morph):**\n- Search 'ChatAdapter' in adapter/chat.rs for existing structure\n- Search 'format_system_message' for current system prompt generation\n- Search 'parse_response' for current marker extraction logic\n- Search 'OutputFormatContent' and 'render' in baml-bridge for schema rendering\n- Search 'jsonish::from_str' or 'deserialize' in jsonish for parsing API\n- Search 'run_user_checks' in jsonish for constraint evaluation\n\n**New methods to add:**\n1. `format_field_descriptions<S: Signature>() -> String` - iterate fields, include type names\n2. `format_field_structure<S: Signature>() -> String` - marker skeleton with field names\n3. `format_system_message_typed<S: Signature>() -> Result<String>` - combines description + structure + BAML schema\n4. `format_user_message_typed<S: Signature>(input: &S::Input) -> String` - render input fields with markers\n5. `extract_field(content: &str, name: &str) -> Result<String, String>` - extract between markers\n6. `parse_response_typed<S: Signature>(response: &Message) -> Result<(S::Output, IndexMap<String, FieldMeta>), ParseError>`\n\n**Parsing algorithm:**\n```rust\nfor each output FieldSpec:\n    1. Extract raw_text between [[ ## name ## ]] markers\n    2. Parse via: jsonish::from_str(output_format, type_ir, raw_text, true)\n    3. Collect flags from BamlValueWithFlags\n    4. Run run_user_checks(value, type_ir) for constraints\n    5. Failed asserts -> ParseError::AssertFailed\n    6. Store FieldMeta { raw_text, flags, checks }\nReturn (S::Output converted from BamlValue, metas)\n```\n\n**PromptParts trait:** May need trait for input.prompt_parts() to get field values without reflection.","acceptance_criteria":"1. format_system_message_typed embeds BAML schema from OutputFormatContent::render()\n2. format_user_message_typed renders input fields with markers\n3. extract_field correctly parses [[ ## name ## ]] protocol\n4. parse_response_typed uses jsonish for coercion\n5. Constraints evaluated via run_user_checks\n6. Returns (typed_output, IndexMap<field, FieldMeta>)\n7. ParseError::Multiple returned when multiple fields fail","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984917767,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.6","created_at":[1767984935213,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 5: Implement Predict<S> typed predictor","description":"Create the generic Predict<S: Signature> predictor that replaces the untyped Predict, with call() and call_with_meta() methods.\n\n**Files to modify:**\n- crates/dspy-rs/src/predictors/predict.rs - new Predict<S> struct and impl\n\n**Search context (use morph):**\n- Search 'struct Predict' in predictors/predict.rs for existing structure\n- Search 'impl Predict' for current forward/call implementation\n- Search 'GLOBAL_SETTINGS' for how adapter/lm are obtained\n- Search 'ToolDyn' for tool handling pattern\n- Search 'CallResult' (will need to use new one from core/call_result.rs)\n\n**New struct:**\n```rust\npub struct Predict<S: Signature> {\n    tools: Vec<Arc<dyn ToolDyn>>,\n    demos: Vec<S>,\n    instruction_override: Option<String>,\n    _marker: PhantomData<S>,\n}\n```\n\n**API:**\n- `Predict::<QA>::new()` - basic constructor\n- `Predict::<QA>::builder().demo(qa).with_tools(tools).build()` - builder pattern\n- `.call(input: S::Input) -> Result<S, PredictError>` - simple return\n- `.call_with_meta(input: S::Input) -> Result<CallResult<S>, PredictError>` - with metadata\n\n**call_with_meta implementation:**\n```rust\n1. Get adapter/lm from GLOBAL_SETTINGS\n2. system = ChatAdapter.format_system_message_typed::<S>()?\n3. user = ChatAdapter.format_user_message_typed::<S>(&input)\n4. Add demo messages if any\n5. response = lm.call(chat, tools).await.map_err(|e| PredictError::Lm { source: e.into() })?\n6. (typed_output, metas) = ChatAdapter.parse_response_typed::<S>(&response.output)\n     .map_err(|e| PredictError::Parse { source: e, raw_response, lm_usage })?\n7. output = S::from_parts(input, typed_output)\n8. Return CallResult { output, raw_response, lm_usage, tool_calls, fields: metas, ... }\n```\n\n**Tracing integration:** Update NodeType::Predict to not require Arc<dyn MetaSignature>, store signature_name as String instead.","acceptance_criteria":"1. Predict<S: Signature> struct defined\n2. call() returns Result<S, PredictError>\n3. call_with_meta() returns Result<CallResult<S>, PredictError>\n4. PredictError variants correctly populated with context\n5. CallResult contains field metadata from parsing\n6. Demo formatting works via S::into_parts()\n7. Tools properly passed to LM call","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984935213,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.7","created_at":[1767984950299,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 6: Fix naming collisions and caching conflicts","description":"Rename the cache CallResult to avoid collision with new core::CallResult<O>, and decide caching strategy for typed Predict.\n\n**Files to modify:**\n- crates/dspy-rs/src/utils/cache.rs - rename CallResult -> CacheEntry\n- crates/dspy-rs/src/core/lm/mod.rs - update import\n- crates/dspy-rs/src/adapter/chat.rs - update caching code\n\n**Search context (use morph):**\n- Search 'CallResult' in utils/cache.rs for existing definition\n- Search 'use.*CallResult' across dspy-rs for all usages\n- Search 'cache_key' or 'CacheKey' for current caching strategy\n- Search 'Example' in cache code to understand current key structure\n\n**Rename plan:**\n```rust\n// OLD in utils/cache.rs\npub struct CallResult {\n    pub prompt: String,\n    pub prediction: Prediction,\n}\n\n// NEW\npub struct CacheEntry {\n    pub prompt: String,\n    pub prediction: Prediction,\n}\n```\n\n**Caching strategy for typed Predict:**\nOption 1 (recommended for now): Cache at LM layer by prompt hash\n- Key = hash(schema_fingerprint, instruction, rendered_user_message)\n- Store raw assistant response + usage\n- Parsing happens on cache hit (cheap vs LM call)\n\nOption 2 (later): Cache at typed layer\n- Requires stable serialization of S::Input\n- Use input.to_baml_value() then serde_json::to_string\n\n**For MVP:** Mark typed caching as post-MVP, keep existing caching for legacy predictor only.","acceptance_criteria":"1. CallResult renamed to CacheEntry in utils/cache.rs\n2. All usages updated (imports, type annotations)\n3. No naming conflict with core::CallResult<O>\n4. Existing cache functionality preserved for legacy predictor\n5. cargo check passes","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984950299,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.8","created_at":[1767984963952,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 7: Update sign! macro and deprecate legacy macros","description":"Update the sign! convenience macro to use derive(Signature), and deprecate example!/prediction! macros for typed API.\n\n**Files to modify:**\n- crates/dspy-rs/src/lib.rs - update sign! macro, add deprecation notices\n\n**Search context (use morph):**\n- Search 'macro_rules! sign' in lib.rs for current implementation\n- Search 'macro_rules! example' for example! macro\n- Search 'macro_rules! prediction' for prediction! macro\n- Search '#[deprecated' for deprecation attribute pattern\n\n**Current sign! behavior:**\n```rust\nsign!{ (question: String) -> answer: String }\n// Generates #[Signature] struct + returns runtime object\n```\n\n**New sign! behavior:**\n```rust\nsign!{ (question: String) -> answer: String }\n// Should generate #[derive(Signature)] struct\n// Returns Predict::<InlineSignature>::new() for chained .call()\n```\n\n**Macro should expand to:**\n```rust\n{\n    #[derive(Signature)]\n    struct __InlineSignature {\n        #[input] question: String,\n        #[output] answer: String,\n    }\n    Predict::<__InlineSignature>::new()\n}\n```\n\n**Deprecation:**\n```rust\n#[deprecated(note = \"Use typed Input struct instead, e.g., QAInput { question: ... }\")]\nmacro_rules! example { ... }\n\n#[deprecated(note = \"Predict<S>::call() returns typed S directly\")]\nmacro_rules! prediction { ... }\n```\n\nOr move to a 'legacy' module if full removal is too disruptive.","acceptance_criteria":"1. sign! macro generates #[derive(Signature)] code\n2. sign! returns Predict::<InlineSignature>::new()\n3. example! macro deprecated with helpful message\n4. prediction! macro deprecated with helpful message\n5. Documentation updated for new typed API","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984963952,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.9","created_at":[1767984980536,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 8: Update optimizer and Module trait for BamlValue interchange","description":"Refactor Module trait and optimizers to use BamlValue interchange instead of Example/Prediction. This can be done in a second wave.\n\n**Files to modify:**\n- crates/dspy-rs/src/core/module.rs - new Module trait with forward_untyped\n- crates/dspy-rs/src/optimizer/*.rs - update to use BamlValue\n\n**Search context (use morph):**\n- Search 'trait Module' in core/module.rs for current definition\n- Search 'impl Module' across codebase for implementations\n- Search 'forward.*Example' for current signature\n- Search 'Prediction' in optimizer for usage patterns\n- Search 'BamlValue' in baml-types for value structure\n\n**Two migration paths:**\n\n**Path A (minimum breakage - recommended initially):**\n- Keep existing Predict + MetaSignature for optimizers only\n- Typed Predict<S> is user-facing, separate ecosystem\n- Optimizers continue to work unchanged\n\n**Path B (spec-consistent - eventual goal):**\n```rust\n// NEW Module trait\npub trait Module: Send + Sync {\n    fn forward_untyped(\n        &self,\n        input: BamlValue,\n    ) -> impl Future<Output = Result<BamlValue, PredictError>> + Send;\n\n    fn signature_spec(&self) -> &'static [FieldSpec];\n}\n\n// Implement for Predict<S>\nimpl<S: Signature> Module for Predict<S> {\n    async fn forward_untyped(&self, input: BamlValue) -> Result<BamlValue, PredictError> {\n        let typed_input = S::Input::try_from_baml_value(input)?;\n        let result = self.call(typed_input).await?;\n        Ok(result.to_baml_value())\n    }\n}\n```\n\n**Required for Path B:**\n- ToBamlValue impl on Signature struct S (via __SAll delegation)\n- Update all optimizer code to call forward_untyped\n- Update evaluation logic to use BamlValue instead of Prediction","acceptance_criteria":"Path A acceptance (MVP):\n1. Existing optimizers continue to work with legacy Predict\n2. No breaking changes to optimizer API\n\nPath B acceptance (eventual):\n1. Module trait has forward_untyped method\n2. Predict<S> implements Module\n3. Optimizers work with typed predictor via BamlValue interchange\n4. Evaluation uses BamlValue instead of Prediction","priority":2,"type":"task","labels":[],"status":"open","_at":[1767984980536,1],"_by":"darin@darinsmacstudio.lan"}
