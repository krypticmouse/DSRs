{"id":"dsrs-ohh","created_at":[1767986111614,1],"created_by":"darin@darinsmacstudio.lan","title":"BAML-Bridge Typed DSPy-RS Integration","description":"# Strategic Goal\n\nTransform DSPy-RS from untyped HashMap-based API to fully typed Rust structs, leveraging BAML-Bridge for schema generation and parsing. This is a **foundational infrastructure change** that enables:\n\n1. **Developer Experience**: Compile-time field validation, IDE autocomplete, direct field access\n2. **Reliability**: Sophisticated LLM output parsing via jsonish (handles quirks, partial outputs)\n3. **Observability**: Rich metadata per field (raw text, parsing flags, constraint results)\n4. **Correctness**: Constraint system (check=soft warning, assert=hard error)\n\n## Current State (Legacy)\n\n```\nUser code → Example (HashMap<String, Value>) → MetaSignature → ChatAdapter → LLM\nLLM → ChatAdapter.parse_response → Prediction (HashMap<String, Value>) → User code\n```\n\n**Problems:**\n- Runtime field access: `result.get(\"answer\").unwrap().as_str().unwrap()`\n- No compile-time validation of field names/types\n- Coarse error handling (anyhow::Result)\n- Basic JSON parsing (doesn't handle LLM quirks)\n- No constraint validation\n\n## Target State (Typed)\n\n```\nUser code → QAInput (typed) → Signature trait → ChatAdapter.format_typed → LLM\nLLM → ChatAdapter.parse_typed → jsonish → BamlValue → QA (typed) → User code\n```\n\n**Benefits:**\n- Direct field access: `result.answer`\n- Compile-time field validation\n- Structured errors with partial results\n- jsonish parser handles LLM output quirks\n- check/assert constraint validation\n\n## Key Design Decisions\n\n1. **Three Generated Structs**: QAInput (public), __QAOutput (hidden), __QAAll (hidden for delegation)\n2. **Function Pointers for TypeIR**: `fn() -> TypeIR` because TypeIR isn't const-constructible\n3. **ParseError::Multiple**: Collect ALL field failures, not just first\n4. **Marker Protocol**: Keep `[[ ## field ## ]]` markers, add BAML schema in system message\n\n## Reference Files\n- CURRENT_PLAN.md - Detailed implementation walkthrough\n- CURRENT_SPEC.md - API specification and acceptance criteria\n- crates/dspy-rs/src/core/signature.rs - Legacy MetaSignature trait\n- baml-bridge/crates/bridge/src/lib.rs - BamlType, parse_llm_output, Parsed<T>","acceptance_criteria":"1. #[derive(Signature)] generates QAInput, __QAOutput, impl Signature for user struct\n2. Predict<S>::call(input) returns Result<S, PredictError> with typed output\n3. CallResult<S> provides field_flags(), field_checks(), field_raw() accessors\n4. PredictError hierarchy: Lm/Parse/Conversion with structured context\n5. ParseError::Multiple preserves partial results\n6. All existing tests pass (backward compatibility via feature flag or parallel API)\n7. New typed API has integration test with real LLM call","priority":0,"type":"epic","labels":[],"status":"open","_at":[1767986111614,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.1","created_at":[1767986126009,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 0: Foundation - Dependencies and Re-exports","description":"# Purpose\n\nEstablish the bridge between dspy-rs and baml-bridge crates. This is foundational scaffolding that enables all subsequent work.\n\n## Why This Matters\n\nThe derive(Signature) macro will generate code that references types like `TypeIR`, `Constraint`, `OutputFormatContent`. These must be accessible via `dspy_rs::` paths so:\n1. User code doesn't need to depend on baml-bridge directly\n2. Macro-generated code has stable import paths\n3. Version coupling is managed in one place (dspy-rs Cargo.toml)\n\n## Technical Context\n\nbaml-bridge exposes:\n- `BamlType` derive macro + trait\n- `baml_types::{TypeIR, BamlValue, Constraint, ...}`\n- `internal_baml_jinja::types::{OutputFormatContent, RenderOptions}`\n- `jsonish::deserializer::...` for parsing\n\n## Risk Assessment\n- LOW: This is configuration, not complex logic\n- Compile-time validation: cargo check will catch missing re-exports\n\n## Search Context (for future self)\n- `baml-bridge/crates/bridge/src/lib.rs:1-30` - public exports\n- `crates/dspy-rs/Cargo.toml` - dependency section\n- `crates/dspy-rs/src/lib.rs` - existing re-export pattern","acceptance_criteria":"1. baml-bridge dependency added to Cargo.toml\n2. Re-exports in lib.rs compile successfully\n3. cargo check passes for dspy-rs crate","priority":1,"type":"epic","labels":[],"status":"open","_at":[1767986126009,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-ohh.1.1","created_at":[1767986135863,1],"created_by":"darin@darinsmacstudio.lan","title":"Add baml-bridge path dependency to Cargo.toml","description":"# Task\n\nAdd baml-bridge as a path dependency to dspy-rs.\n\n## File to Modify\n`crates/dspy-rs/Cargo.toml`\n\n## Change\nAdd to [dependencies]:\n```toml\nbaml-bridge = { path = \"../../baml-bridge/crates/bridge\", features = [\"derive\"] }\n```\n\n## Why 'derive' Feature\nThe derive feature enables `#[derive(BamlType)]` which we need for generated structs.\n\n## Search Context\n- Use morph: `[dependencies]` in crates/dspy-rs/Cargo.toml\n- Use morph: `features` in baml-bridge/crates/bridge/Cargo.toml\n\n## Verification\n```bash\ncd crates/dspy-rs && cargo check\n```\n\n## Gotcha\nPath is relative from crates/dspy-rs, so `../../baml-bridge/crates/bridge` goes up to repo root then into baml-bridge.","acceptance_criteria":"cargo check passes with baml-bridge dependency","priority":1,"type":"task","labels":[],"status":"open","_at":[1767986135863,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr","created_at":[1767984841920,0],"created_by":"darin@darinsmacstudio.lan","title":"BAML-Bridge Integration: Typed DSPy-RS API","description":"Migrate dspy-rs from untyped HashMap<String, serde_json::Value> to typed Signature structs using baml-bridge for schema rendering and jsonish parsing. Transforms user-facing API from Example/Prediction to typed QAInput/QA structs. See CURRENT_PLAN.md and CURRENT_SPEC.md for full details.","acceptance_criteria":"1. #[derive(Signature)] generates QAInput, __QAOutput, impl Signature\n2. ChatAdapter uses BAML OutputFormatContent for schema rendering\n3. Parsing uses jsonish with per-field extraction and constraint evaluation\n4. Predict<S> returns CallResult<S> with field metadata\n5. PredictError hierarchy matches spec (Lm/Parse/Conversion variants)","priority":1,"type":"epic","labels":[],"status":"closed","closed_at":[1767986091322,1],"closed_by":"darin@darinsmacstudio.lan","closed_reason":"Restructuring: replacing with more granular epic","_at":[1767986091322,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1767984841920,0],"darin@darinsmacstudio.lan"],"claim":[[1767984841920,0],"darin@darinsmacstudio.lan"],"description":[[1767984841920,0],"darin@darinsmacstudio.lan"],"design":[[1767984841920,0],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1767984841920,0],"darin@darinsmacstudio.lan"],"external_ref":[[1767984841920,0],"darin@darinsmacstudio.lan"],"labels":[[1767984841920,0],"darin@darinsmacstudio.lan"],"priority":[[1767984841920,0],"darin@darinsmacstudio.lan"],"source_repo":[[1767984841920,0],"darin@darinsmacstudio.lan"],"title":[[1767984841920,0],"darin@darinsmacstudio.lan"],"type":[[1767984841920,0],"darin@darinsmacstudio.lan"]}}
{"id":"dsrs-vyr.1","created_at":[1767984854449,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 0: Add baml-bridge dependency and re-exports","description":"Add baml-bridge path dependency to dspy-rs and set up re-exports for macro-generated code.\n\n**Files to modify:**\n- crates/dspy-rs/Cargo.toml - add baml-bridge dependency\n- crates/dspy-rs/src/lib.rs - add re-exports\n\n**Search context (use morph):**\n- Search 'baml-bridge/crates/bridge' for available public types\n- Search 'pub use' in dspy-rs/src/lib.rs for existing re-export pattern\n- Search 'BamlValue' and 'TypeIR' in baml-bridge for types to re-export\n\n**Re-exports needed:**\n```rust\npub use baml_bridge::BamlType;\npub use baml_bridge::baml_types::{BamlValue, Constraint, ConstraintLevel, ResponseCheck, TypeIR, StreamingMode, TypeValue};\npub use baml_bridge::internal_baml_jinja::types::{OutputFormatContent, RenderOptions};\npub use baml_bridge::jsonish::deserializer::deserialize_flags::Flag;\n```\n\n**Dependency path:** `baml-bridge = { path = \"../../baml-bridge/crates/bridge\", features = [\"derive\"] }`","acceptance_criteria":"1. Cargo.toml has baml-bridge dependency\n2. lib.rs re-exports BamlType, TypeIR, Constraint, OutputFormatContent, Flag\n3. cargo check passes in dspy-rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984854449,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.2","created_at":[1767984869507,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 1: Define typed Signature trait and core types","description":"Create the new typed Signature trait, FieldSpec, ConstraintSpec, and error types that replace the legacy MetaSignature.\n\n**Files to create/modify:**\n- crates/dspy-rs/src/core/signature.rs - new typed Signature trait + FieldSpec/ConstraintSpec\n- crates/dspy-rs/src/core/errors.rs (NEW) - PredictError, ParseError, ConversionError hierarchy\n- crates/dspy-rs/src/core/call_result.rs (NEW) - CallResult<O> with FieldMeta\n- crates/dspy-rs/src/core/mod.rs - re-export new modules\n\n**Search context (use morph):**\n- Search 'MetaSignature' in dspy-rs to understand legacy trait\n- Search 'FieldMeta' or 'field metadata' in baml-bridge for inspiration\n- Search 'thiserror' in Cargo.toml to check if available\n- Search 'ResponseCheck' in baml-types for constraint result patterns\n\n**New types to define:**\n```rust\npub struct FieldSpec {\n    pub name: &'static str,       // LLM-facing name (alias or original)\n    pub rust_name: &'static str,  // Rust field ident\n    pub description: &'static str,\n    pub type_ir: fn() -> TypeIR,\n    pub constraints: &'static [ConstraintSpec],\n}\n\npub trait Signature: Send + Sync + 'static {\n    type Input: baml_bridge::BamlType;\n    type Output: baml_bridge::BamlType;\n    fn instruction() -> &'static str;\n    fn input_fields() -> &'static [FieldSpec];\n    fn output_fields() -> &'static [FieldSpec];\n    fn output_format_content() -> &'static OutputFormatContent;\n    fn from_parts(input: Self::Input, output: Self::Output) -> Self;\n    fn into_parts(self) -> (Self::Input, Self::Output);\n}\n```","acceptance_criteria":"1. FieldSpec, ConstraintSpec, ConstraintKind types defined\n2. Typed Signature trait with Input/Output associated types\n3. PredictError with Lm/Parse/Conversion variants\n4. ParseError with MissingField/ExtractionFailed/CoercionFailed/AssertFailed/Multiple variants\n5. CallResult<O> with field_flags(), field_checks(), field_raw() accessors\n6. All types exported from core/mod.rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984869507,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.3","created_at":[1767984884339,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 2: Add ToBamlValue trait in baml-bridge","description":"Add the missing ToBamlValue trait to convert typed Rust values to BamlValue for prompt rendering. This enables typed demos and inputs without serde_json::Value.\n\n**Files to modify:**\n- baml-bridge/crates/bridge/src/lib.rs - add ToBamlValue trait + impls\n- baml-bridge/crates/baml-bridge-derive/src/lib.rs - extend derive(BamlType) to impl ToBamlValue\n\n**Search context (use morph):**\n- Search 'BamlValueConvert' in bridge for existing from-value conversion pattern\n- Search 'BamlValue::Class' or 'BamlValue::Enum' for value construction\n- Search 'derive(BamlType)' in baml-bridge-derive for macro expansion pattern\n- Search 'to_baml' or 'into_baml' for any existing conversion\n\n**New trait:**\n```rust\npub trait ToBamlValue {\n    fn to_baml_value(&self) -> baml_types::BamlValue;\n}\n```\n\n**Implement for:**\n- Primitives: String, &str, bool, i32, i64, f32, f64, etc.\n- Containers: Option<T>, Vec<T>, HashMap<String, T>, BTreeMap<String, T>\n- derive(BamlType) structs: convert each field, return BamlValue::Class(name, map)\n- derive(BamlType) enums: return BamlValue::Enum(enum_name, variant_string)\n\n**Critical:** Mirror the exact representation that BamlValueConvert expects when parsing. Check how parsing returns enums/classes and produce the inverse.","acceptance_criteria":"1. ToBamlValue trait defined and exported from bridge\n2. Primitive types implement ToBamlValue (String, bool, numerics)\n3. Option<T>, Vec<T>, HashMap<String,T> implement ToBamlValue\n4. derive(BamlType) generates ToBamlValue impl for structs\n5. derive(BamlType) generates ToBamlValue impl for enums\n6. Round-trip test: to_baml_value() -> try_from_baml_value() == original","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984884339,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.4","created_at":[1767984901199,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 3: Implement derive(Signature) macro","description":"Replace the existing #[Signature] attribute macro with #[derive(Signature)] that generates typed input/output structs and Signature trait impl.\n\n**Files to modify:**\n- crates/dsrs-macros/src/lib.rs - add proc_macro_derive(Signature), rename/gate old attribute macro\n- crates/dsrs-macros/Cargo.toml - ensure syn/quote dependencies support derives\n\n**Search context (use morph):**\n- Search 'proc_macro_attribute' in dsrs-macros for existing Signature macro\n- Search 'proc_macro_derive' for derive macro pattern examples\n- Search 'BamlType' derive in baml-bridge-derive for struct/field parsing\n- Search 'syn::DeriveInput' for derive input parsing pattern\n\n**Given user code:**\n```rust\n#[derive(Signature)]\n/// Answer questions accurately\npub struct QA {\n    #[input] pub question: String,\n    #[input] pub context: Option<String>,\n    #[output] pub answer: String,\n    #[output] #[check(\"this >= 0.0\", label = \"range\")] pub confidence: f32,\n}\n```\n\n**Must generate:**\n1. `QAInput` - public struct with only #[input] fields, derives BamlType\n2. `__QAOutput` - hidden struct with only #[output] fields, derives BamlType\n3. `__QAAll` - hidden struct with all fields for delegation\n4. BamlType/BamlValueConvert/ToBamlValue impls for QA via delegation to __QAAll\n5. `impl Signature for QA` with Input/Output types, instruction from doc comment\n6. Static `__QA_INPUT_FIELDS` and `__QA_OUTPUT_FIELDS` slices of FieldSpec\n7. fn pointers for type_ir construction with constraints\n\n**Validation rules:**\n- Struct only, named fields only\n- Each field must have exactly one of #[input] or #[output]\n- Must have >= 1 input and >= 1 output\n- #[check(...)] must include label = \"...\"","acceptance_criteria":"1. derive(Signature) compiles and generates QAInput, __QAOutput\n2. Generated QAInput derives BamlType\n3. impl Signature for QA with correct associated types\n4. input_fields() and output_fields() return static FieldSpec slices\n5. from_parts/into_parts work correctly\n6. Compile errors for: missing input, missing output, no label on check","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984901199,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.5","created_at":[1767984917767,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 4: Typed prompting and parsing in ChatAdapter","description":"Add typed formatting and parsing functions to ChatAdapter that use BAML schema rendering and jsonish parsing.\n\n**Files to modify:**\n- crates/dspy-rs/src/adapter/chat.rs - add typed format/parse functions\n\n**Search context (use morph):**\n- Search 'ChatAdapter' in adapter/chat.rs for existing structure\n- Search 'format_system_message' for current system prompt generation\n- Search 'parse_response' for current marker extraction logic\n- Search 'OutputFormatContent' and 'render' in baml-bridge for schema rendering\n- Search 'jsonish::from_str' or 'deserialize' in jsonish for parsing API\n- Search 'run_user_checks' in jsonish for constraint evaluation\n\n**New methods to add:**\n1. `format_field_descriptions<S: Signature>() -> String` - iterate fields, include type names\n2. `format_field_structure<S: Signature>() -> String` - marker skeleton with field names\n3. `format_system_message_typed<S: Signature>() -> Result<String>` - combines description + structure + BAML schema\n4. `format_user_message_typed<S: Signature>(input: &S::Input) -> String` - render input fields with markers\n5. `extract_field(content: &str, name: &str) -> Result<String, String>` - extract between markers\n6. `parse_response_typed<S: Signature>(response: &Message) -> Result<(S::Output, IndexMap<String, FieldMeta>), ParseError>`\n\n**Parsing algorithm:**\n```rust\nfor each output FieldSpec:\n    1. Extract raw_text between [[ ## name ## ]] markers\n    2. Parse via: jsonish::from_str(output_format, type_ir, raw_text, true)\n    3. Collect flags from BamlValueWithFlags\n    4. Run run_user_checks(value, type_ir) for constraints\n    5. Failed asserts -> ParseError::AssertFailed\n    6. Store FieldMeta { raw_text, flags, checks }\nReturn (S::Output converted from BamlValue, metas)\n```\n\n**PromptParts trait:** May need trait for input.prompt_parts() to get field values without reflection.","acceptance_criteria":"1. format_system_message_typed embeds BAML schema from OutputFormatContent::render()\n2. format_user_message_typed renders input fields with markers\n3. extract_field correctly parses [[ ## name ## ]] protocol\n4. parse_response_typed uses jsonish for coercion\n5. Constraints evaluated via run_user_checks\n6. Returns (typed_output, IndexMap<field, FieldMeta>)\n7. ParseError::Multiple returned when multiple fields fail","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984917767,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.6","created_at":[1767984935213,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 5: Implement Predict<S> typed predictor","description":"Create the generic Predict<S: Signature> predictor that replaces the untyped Predict, with call() and call_with_meta() methods.\n\n**Files to modify:**\n- crates/dspy-rs/src/predictors/predict.rs - new Predict<S> struct and impl\n\n**Search context (use morph):**\n- Search 'struct Predict' in predictors/predict.rs for existing structure\n- Search 'impl Predict' for current forward/call implementation\n- Search 'GLOBAL_SETTINGS' for how adapter/lm are obtained\n- Search 'ToolDyn' for tool handling pattern\n- Search 'CallResult' (will need to use new one from core/call_result.rs)\n\n**New struct:**\n```rust\npub struct Predict<S: Signature> {\n    tools: Vec<Arc<dyn ToolDyn>>,\n    demos: Vec<S>,\n    instruction_override: Option<String>,\n    _marker: PhantomData<S>,\n}\n```\n\n**API:**\n- `Predict::<QA>::new()` - basic constructor\n- `Predict::<QA>::builder().demo(qa).with_tools(tools).build()` - builder pattern\n- `.call(input: S::Input) -> Result<S, PredictError>` - simple return\n- `.call_with_meta(input: S::Input) -> Result<CallResult<S>, PredictError>` - with metadata\n\n**call_with_meta implementation:**\n```rust\n1. Get adapter/lm from GLOBAL_SETTINGS\n2. system = ChatAdapter.format_system_message_typed::<S>()?\n3. user = ChatAdapter.format_user_message_typed::<S>(&input)\n4. Add demo messages if any\n5. response = lm.call(chat, tools).await.map_err(|e| PredictError::Lm { source: e.into() })?\n6. (typed_output, metas) = ChatAdapter.parse_response_typed::<S>(&response.output)\n     .map_err(|e| PredictError::Parse { source: e, raw_response, lm_usage })?\n7. output = S::from_parts(input, typed_output)\n8. Return CallResult { output, raw_response, lm_usage, tool_calls, fields: metas, ... }\n```\n\n**Tracing integration:** Update NodeType::Predict to not require Arc<dyn MetaSignature>, store signature_name as String instead.","acceptance_criteria":"1. Predict<S: Signature> struct defined\n2. call() returns Result<S, PredictError>\n3. call_with_meta() returns Result<CallResult<S>, PredictError>\n4. PredictError variants correctly populated with context\n5. CallResult contains field metadata from parsing\n6. Demo formatting works via S::into_parts()\n7. Tools properly passed to LM call","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984935213,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.7","created_at":[1767984950299,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 6: Fix naming collisions and caching conflicts","description":"Rename the cache CallResult to avoid collision with new core::CallResult<O>, and decide caching strategy for typed Predict.\n\n**Files to modify:**\n- crates/dspy-rs/src/utils/cache.rs - rename CallResult -> CacheEntry\n- crates/dspy-rs/src/core/lm/mod.rs - update import\n- crates/dspy-rs/src/adapter/chat.rs - update caching code\n\n**Search context (use morph):**\n- Search 'CallResult' in utils/cache.rs for existing definition\n- Search 'use.*CallResult' across dspy-rs for all usages\n- Search 'cache_key' or 'CacheKey' for current caching strategy\n- Search 'Example' in cache code to understand current key structure\n\n**Rename plan:**\n```rust\n// OLD in utils/cache.rs\npub struct CallResult {\n    pub prompt: String,\n    pub prediction: Prediction,\n}\n\n// NEW\npub struct CacheEntry {\n    pub prompt: String,\n    pub prediction: Prediction,\n}\n```\n\n**Caching strategy for typed Predict:**\nOption 1 (recommended for now): Cache at LM layer by prompt hash\n- Key = hash(schema_fingerprint, instruction, rendered_user_message)\n- Store raw assistant response + usage\n- Parsing happens on cache hit (cheap vs LM call)\n\nOption 2 (later): Cache at typed layer\n- Requires stable serialization of S::Input\n- Use input.to_baml_value() then serde_json::to_string\n\n**For MVP:** Mark typed caching as post-MVP, keep existing caching for legacy predictor only.","acceptance_criteria":"1. CallResult renamed to CacheEntry in utils/cache.rs\n2. All usages updated (imports, type annotations)\n3. No naming conflict with core::CallResult<O>\n4. Existing cache functionality preserved for legacy predictor\n5. cargo check passes","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984950299,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.8","created_at":[1767984963952,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 7: Update sign! macro and deprecate legacy macros","description":"Update the sign! convenience macro to use derive(Signature), and deprecate example!/prediction! macros for typed API.\n\n**Files to modify:**\n- crates/dspy-rs/src/lib.rs - update sign! macro, add deprecation notices\n\n**Search context (use morph):**\n- Search 'macro_rules! sign' in lib.rs for current implementation\n- Search 'macro_rules! example' for example! macro\n- Search 'macro_rules! prediction' for prediction! macro\n- Search '#[deprecated' for deprecation attribute pattern\n\n**Current sign! behavior:**\n```rust\nsign!{ (question: String) -> answer: String }\n// Generates #[Signature] struct + returns runtime object\n```\n\n**New sign! behavior:**\n```rust\nsign!{ (question: String) -> answer: String }\n// Should generate #[derive(Signature)] struct\n// Returns Predict::<InlineSignature>::new() for chained .call()\n```\n\n**Macro should expand to:**\n```rust\n{\n    #[derive(Signature)]\n    struct __InlineSignature {\n        #[input] question: String,\n        #[output] answer: String,\n    }\n    Predict::<__InlineSignature>::new()\n}\n```\n\n**Deprecation:**\n```rust\n#[deprecated(note = \"Use typed Input struct instead, e.g., QAInput { question: ... }\")]\nmacro_rules! example { ... }\n\n#[deprecated(note = \"Predict<S>::call() returns typed S directly\")]\nmacro_rules! prediction { ... }\n```\n\nOr move to a 'legacy' module if full removal is too disruptive.","acceptance_criteria":"1. sign! macro generates #[derive(Signature)] code\n2. sign! returns Predict::<InlineSignature>::new()\n3. example! macro deprecated with helpful message\n4. prediction! macro deprecated with helpful message\n5. Documentation updated for new typed API","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984963952,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.9","created_at":[1767984980536,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 8: Update optimizer and Module trait for BamlValue interchange","description":"Refactor Module trait and optimizers to use BamlValue interchange instead of Example/Prediction. This can be done in a second wave.\n\n**Files to modify:**\n- crates/dspy-rs/src/core/module.rs - new Module trait with forward_untyped\n- crates/dspy-rs/src/optimizer/*.rs - update to use BamlValue\n\n**Search context (use morph):**\n- Search 'trait Module' in core/module.rs for current definition\n- Search 'impl Module' across codebase for implementations\n- Search 'forward.*Example' for current signature\n- Search 'Prediction' in optimizer for usage patterns\n- Search 'BamlValue' in baml-types for value structure\n\n**Two migration paths:**\n\n**Path A (minimum breakage - recommended initially):**\n- Keep existing Predict + MetaSignature for optimizers only\n- Typed Predict<S> is user-facing, separate ecosystem\n- Optimizers continue to work unchanged\n\n**Path B (spec-consistent - eventual goal):**\n```rust\n// NEW Module trait\npub trait Module: Send + Sync {\n    fn forward_untyped(\n        &self,\n        input: BamlValue,\n    ) -> impl Future<Output = Result<BamlValue, PredictError>> + Send;\n\n    fn signature_spec(&self) -> &'static [FieldSpec];\n}\n\n// Implement for Predict<S>\nimpl<S: Signature> Module for Predict<S> {\n    async fn forward_untyped(&self, input: BamlValue) -> Result<BamlValue, PredictError> {\n        let typed_input = S::Input::try_from_baml_value(input)?;\n        let result = self.call(typed_input).await?;\n        Ok(result.to_baml_value())\n    }\n}\n```\n\n**Required for Path B:**\n- ToBamlValue impl on Signature struct S (via __SAll delegation)\n- Update all optimizer code to call forward_untyped\n- Update evaluation logic to use BamlValue instead of Prediction","acceptance_criteria":"Path A acceptance (MVP):\n1. Existing optimizers continue to work with legacy Predict\n2. No breaking changes to optimizer API\n\nPath B acceptance (eventual):\n1. Module trait has forward_untyped method\n2. Predict<S> implements Module\n3. Optimizers work with typed predictor via BamlValue interchange\n4. Evaluation uses BamlValue instead of Prediction","priority":2,"type":"task","labels":[],"status":"open","_at":[1767984980536,1],"_by":"darin@darinsmacstudio.lan"}
