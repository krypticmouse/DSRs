{"id":"dsrs-vyr","created_at":[1767984841920,0],"created_by":"darin@darinsmacstudio.lan","title":"BAML-Bridge Integration: Typed DSPy-RS API","description":"Migrate dspy-rs from untyped HashMap<String, serde_json::Value> to typed Signature structs using baml-bridge for schema rendering and jsonish parsing. Transforms user-facing API from Example/Prediction to typed QAInput/QA structs. See CURRENT_PLAN.md and CURRENT_SPEC.md for full details.","acceptance_criteria":"1. #[derive(Signature)] generates QAInput, __QAOutput, impl Signature\n2. ChatAdapter uses BAML OutputFormatContent for schema rendering\n3. Parsing uses jsonish with per-field extraction and constraint evaluation\n4. Predict<S> returns CallResult<S> with field metadata\n5. PredictError hierarchy matches spec (Lm/Parse/Conversion variants)","priority":1,"type":"epic","labels":[],"status":"open","_at":[1767984841920,0],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.1","created_at":[1767984854449,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 0: Add baml-bridge dependency and re-exports","description":"Add baml-bridge path dependency to dspy-rs and set up re-exports for macro-generated code.\n\n**Files to modify:**\n- crates/dspy-rs/Cargo.toml - add baml-bridge dependency\n- crates/dspy-rs/src/lib.rs - add re-exports\n\n**Search context (use morph):**\n- Search 'baml-bridge/crates/bridge' for available public types\n- Search 'pub use' in dspy-rs/src/lib.rs for existing re-export pattern\n- Search 'BamlValue' and 'TypeIR' in baml-bridge for types to re-export\n\n**Re-exports needed:**\n```rust\npub use baml_bridge::BamlType;\npub use baml_bridge::baml_types::{BamlValue, Constraint, ConstraintLevel, ResponseCheck, TypeIR, StreamingMode, TypeValue};\npub use baml_bridge::internal_baml_jinja::types::{OutputFormatContent, RenderOptions};\npub use baml_bridge::jsonish::deserializer::deserialize_flags::Flag;\n```\n\n**Dependency path:** `baml-bridge = { path = \"../../baml-bridge/crates/bridge\", features = [\"derive\"] }`","acceptance_criteria":"1. Cargo.toml has baml-bridge dependency\n2. lib.rs re-exports BamlType, TypeIR, Constraint, OutputFormatContent, Flag\n3. cargo check passes in dspy-rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984854449,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.2","created_at":[1767984869507,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 1: Define typed Signature trait and core types","description":"Create the new typed Signature trait, FieldSpec, ConstraintSpec, and error types that replace the legacy MetaSignature.\n\n**Files to create/modify:**\n- crates/dspy-rs/src/core/signature.rs - new typed Signature trait + FieldSpec/ConstraintSpec\n- crates/dspy-rs/src/core/errors.rs (NEW) - PredictError, ParseError, ConversionError hierarchy\n- crates/dspy-rs/src/core/call_result.rs (NEW) - CallResult<O> with FieldMeta\n- crates/dspy-rs/src/core/mod.rs - re-export new modules\n\n**Search context (use morph):**\n- Search 'MetaSignature' in dspy-rs to understand legacy trait\n- Search 'FieldMeta' or 'field metadata' in baml-bridge for inspiration\n- Search 'thiserror' in Cargo.toml to check if available\n- Search 'ResponseCheck' in baml-types for constraint result patterns\n\n**New types to define:**\n```rust\npub struct FieldSpec {\n    pub name: &'static str,       // LLM-facing name (alias or original)\n    pub rust_name: &'static str,  // Rust field ident\n    pub description: &'static str,\n    pub type_ir: fn() -> TypeIR,\n    pub constraints: &'static [ConstraintSpec],\n}\n\npub trait Signature: Send + Sync + 'static {\n    type Input: baml_bridge::BamlType;\n    type Output: baml_bridge::BamlType;\n    fn instruction() -> &'static str;\n    fn input_fields() -> &'static [FieldSpec];\n    fn output_fields() -> &'static [FieldSpec];\n    fn output_format_content() -> &'static OutputFormatContent;\n    fn from_parts(input: Self::Input, output: Self::Output) -> Self;\n    fn into_parts(self) -> (Self::Input, Self::Output);\n}\n```","acceptance_criteria":"1. FieldSpec, ConstraintSpec, ConstraintKind types defined\n2. Typed Signature trait with Input/Output associated types\n3. PredictError with Lm/Parse/Conversion variants\n4. ParseError with MissingField/ExtractionFailed/CoercionFailed/AssertFailed/Multiple variants\n5. CallResult<O> with field_flags(), field_checks(), field_raw() accessors\n6. All types exported from core/mod.rs","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984869507,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.3","created_at":[1767984884339,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 2: Add ToBamlValue trait in baml-bridge","description":"Add the missing ToBamlValue trait to convert typed Rust values to BamlValue for prompt rendering. This enables typed demos and inputs without serde_json::Value.\n\n**Files to modify:**\n- baml-bridge/crates/bridge/src/lib.rs - add ToBamlValue trait + impls\n- baml-bridge/crates/baml-bridge-derive/src/lib.rs - extend derive(BamlType) to impl ToBamlValue\n\n**Search context (use morph):**\n- Search 'BamlValueConvert' in bridge for existing from-value conversion pattern\n- Search 'BamlValue::Class' or 'BamlValue::Enum' for value construction\n- Search 'derive(BamlType)' in baml-bridge-derive for macro expansion pattern\n- Search 'to_baml' or 'into_baml' for any existing conversion\n\n**New trait:**\n```rust\npub trait ToBamlValue {\n    fn to_baml_value(&self) -> baml_types::BamlValue;\n}\n```\n\n**Implement for:**\n- Primitives: String, &str, bool, i32, i64, f32, f64, etc.\n- Containers: Option<T>, Vec<T>, HashMap<String, T>, BTreeMap<String, T>\n- derive(BamlType) structs: convert each field, return BamlValue::Class(name, map)\n- derive(BamlType) enums: return BamlValue::Enum(enum_name, variant_string)\n\n**Critical:** Mirror the exact representation that BamlValueConvert expects when parsing. Check how parsing returns enums/classes and produce the inverse.","acceptance_criteria":"1. ToBamlValue trait defined and exported from bridge\n2. Primitive types implement ToBamlValue (String, bool, numerics)\n3. Option<T>, Vec<T>, HashMap<String,T> implement ToBamlValue\n4. derive(BamlType) generates ToBamlValue impl for structs\n5. derive(BamlType) generates ToBamlValue impl for enums\n6. Round-trip test: to_baml_value() -> try_from_baml_value() == original","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984884339,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.4","created_at":[1767984901199,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 3: Implement derive(Signature) macro","description":"Replace the existing #[Signature] attribute macro with #[derive(Signature)] that generates typed input/output structs and Signature trait impl.\n\n**Files to modify:**\n- crates/dsrs-macros/src/lib.rs - add proc_macro_derive(Signature), rename/gate old attribute macro\n- crates/dsrs-macros/Cargo.toml - ensure syn/quote dependencies support derives\n\n**Search context (use morph):**\n- Search 'proc_macro_attribute' in dsrs-macros for existing Signature macro\n- Search 'proc_macro_derive' for derive macro pattern examples\n- Search 'BamlType' derive in baml-bridge-derive for struct/field parsing\n- Search 'syn::DeriveInput' for derive input parsing pattern\n\n**Given user code:**\n```rust\n#[derive(Signature)]\n/// Answer questions accurately\npub struct QA {\n    #[input] pub question: String,\n    #[input] pub context: Option<String>,\n    #[output] pub answer: String,\n    #[output] #[check(\"this >= 0.0\", label = \"range\")] pub confidence: f32,\n}\n```\n\n**Must generate:**\n1. `QAInput` - public struct with only #[input] fields, derives BamlType\n2. `__QAOutput` - hidden struct with only #[output] fields, derives BamlType\n3. `__QAAll` - hidden struct with all fields for delegation\n4. BamlType/BamlValueConvert/ToBamlValue impls for QA via delegation to __QAAll\n5. `impl Signature for QA` with Input/Output types, instruction from doc comment\n6. Static `__QA_INPUT_FIELDS` and `__QA_OUTPUT_FIELDS` slices of FieldSpec\n7. fn pointers for type_ir construction with constraints\n\n**Validation rules:**\n- Struct only, named fields only\n- Each field must have exactly one of #[input] or #[output]\n- Must have >= 1 input and >= 1 output\n- #[check(...)] must include label = \"...\"","acceptance_criteria":"1. derive(Signature) compiles and generates QAInput, __QAOutput\n2. Generated QAInput derives BamlType\n3. impl Signature for QA with correct associated types\n4. input_fields() and output_fields() return static FieldSpec slices\n5. from_parts/into_parts work correctly\n6. Compile errors for: missing input, missing output, no label on check","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984901199,1],"_by":"darin@darinsmacstudio.lan"}
{"id":"dsrs-vyr.5","created_at":[1767984917767,1],"created_by":"darin@darinsmacstudio.lan","title":"Phase 4: Typed prompting and parsing in ChatAdapter","description":"Add typed formatting and parsing functions to ChatAdapter that use BAML schema rendering and jsonish parsing.\n\n**Files to modify:**\n- crates/dspy-rs/src/adapter/chat.rs - add typed format/parse functions\n\n**Search context (use morph):**\n- Search 'ChatAdapter' in adapter/chat.rs for existing structure\n- Search 'format_system_message' for current system prompt generation\n- Search 'parse_response' for current marker extraction logic\n- Search 'OutputFormatContent' and 'render' in baml-bridge for schema rendering\n- Search 'jsonish::from_str' or 'deserialize' in jsonish for parsing API\n- Search 'run_user_checks' in jsonish for constraint evaluation\n\n**New methods to add:**\n1. `format_field_descriptions<S: Signature>() -> String` - iterate fields, include type names\n2. `format_field_structure<S: Signature>() -> String` - marker skeleton with field names\n3. `format_system_message_typed<S: Signature>() -> Result<String>` - combines description + structure + BAML schema\n4. `format_user_message_typed<S: Signature>(input: &S::Input) -> String` - render input fields with markers\n5. `extract_field(content: &str, name: &str) -> Result<String, String>` - extract between markers\n6. `parse_response_typed<S: Signature>(response: &Message) -> Result<(S::Output, IndexMap<String, FieldMeta>), ParseError>`\n\n**Parsing algorithm:**\n```rust\nfor each output FieldSpec:\n    1. Extract raw_text between [[ ## name ## ]] markers\n    2. Parse via: jsonish::from_str(output_format, type_ir, raw_text, true)\n    3. Collect flags from BamlValueWithFlags\n    4. Run run_user_checks(value, type_ir) for constraints\n    5. Failed asserts -> ParseError::AssertFailed\n    6. Store FieldMeta { raw_text, flags, checks }\nReturn (S::Output converted from BamlValue, metas)\n```\n\n**PromptParts trait:** May need trait for input.prompt_parts() to get field values without reflection.","acceptance_criteria":"1. format_system_message_typed embeds BAML schema from OutputFormatContent::render()\n2. format_user_message_typed renders input fields with markers\n3. extract_field correctly parses [[ ## name ## ]] protocol\n4. parse_response_typed uses jsonish for coercion\n5. Constraints evaluated via run_user_checks\n6. Returns (typed_output, IndexMap<field, FieldMeta>)\n7. ParseError::Multiple returned when multiple fields fail","priority":1,"type":"task","labels":[],"status":"open","_at":[1767984917767,1],"_by":"darin@darinsmacstudio.lan"}
